diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..714718a
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,201 @@
+cmake_minimum_required(VERSION 3.0)
+
+project(libgpg-error VERSION 1.36.0 LANGUAGES C)
+
+find_package(iconv NO_MODULE REQUIRED)
+
+if(MSVC)
+  set(CMAKE_DEBUG_POSTFIX "d")
+endif()
+
+# find_program(AWK awk)
+# include(FindPackageHandleStandardArgs)
+# find_package_handle_standard_args(AWK REQUIRED_VARS AWK)
+# if(NOT ${AWK_FOUND})
+#   message(FATAL_ERROR "AWK not found, can't generate error codes")
+# endif()
+
+add_library(libgpg-error
+  cmake/libgpg-error.def
+  src/argparse.c
+  src/b64dec.c
+  src/b64enc.c
+  src/code-from-errno.c
+  src/code-from-errno.h
+  src/code-to-errno.c
+  src/code-to-errno.h
+  src/err-codes-sym.h
+  src/err-codes.h
+  src/err-sources-sym.h
+  src/err-sources.h
+  src/errnos-sym.h
+  src/estream-printf.c
+  src/estream-printf.h
+  src/estream.c
+  src/gettext.h
+  # src/gpg-error.c
+  src/gpg-error.h
+  src/gpgrt-int.h
+  src/init.c
+  src/init.h
+  src/lock.h
+  src/logging.c
+  src/strerror-sym.c
+  src/strerror.c
+  src/strsource-sym.c
+  src/strsource.c
+  src/syscall-clamp.c
+  src/sysutils.c
+  src/syscfg/lock-obj-pub.mingw32.h
+  src/thread.h
+  src/version.c
+  src/visibility.c
+  src/visibility.h
+  src/w32-add.h
+  src/w32-estream.c
+  src/w32-gettext.c
+  src/w32-lock-obj.h
+  src/w32-lock.c
+  src/w32-thread.c
+)
+
+if (WINDOWS_STORE)
+  target_compile_definitions(libgpg-error PRIVATE MS_APP)
+else()
+  target_sources(libgpg-error
+    PRIVATE
+      src/w32-reg.c
+  )
+endif()
+
+target_compile_definitions(libgpg-error
+  PRIVATE
+  HAVE_CONFIG_H
+  PKGDATADIR=""
+  _CRT_SECURE_NO_WARNINGS
+  _CRT_NONSTDC_NO_WARNINGS)
+
+target_include_directories(libgpg-error
+  PRIVATE
+  $<BUILD_INTERFACE:.;cmake;src;src/syscfg;${CMAKE_CURRENT_BINARY_DIR}>
+  INTERFACE
+  $<INSTALL_INTERFACE:include>
+)
+
+target_link_libraries(libgpg-error
+  PRIVATE Ws2_32.lib
+  PUBLIC iconv::iconv
+)
+
+# add_custom_command(
+#   TARGET libgpg-error
+#   PRE_BUILD
+#   COMMAND ${AWK} -f ${CMAKE_CURRENT_SOURCE_DIR}/src/mkstrtable.awk -v textidx=3 ${CMAKE_CURRENT_SOURCE_DIR}/src/err-sources.h.in > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/err-sources.h
+#   COMMAND ${AWK} -f ${CMAKE_CURRENT_SOURCE_DIR}/src/mkstrtable.awk -v textidx=2 -v nogettext=1 ${CMAKE_CURRENT_SOURCE_DIR}/src/err-sources.h.in > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/err-sources-sym.h
+#   COMMAND ${AWK} -f ${CMAKE_CURRENT_SOURCE_DIR}/src/mkstrtable.awk -v textidx=3 ${CMAKE_CURRENT_SOURCE_DIR}/src/err-codes.h.in > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/err-codes.h
+#   COMMAND ${AWK} -f ${CMAKE_CURRENT_SOURCE_DIR}/src/mkstrtable.awk -v textidx=2 -v nogettext=1 ${CMAKE_CURRENT_SOURCE_DIR}/src/err-codes.h.in > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/err-codes-sym.h
+#   COMMAND ${AWK} -f ${CMAKE_CURRENT_SOURCE_DIR}/src/mkerrnos.awk ${CMAKE_CURRENT_SOURCE_DIR}/src/errnos.in > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/code-to-errno.h
+#   COMMAND ${AWK} -f ${CMAKE_CURRENT_SOURCE_DIR}/src/mkstrtable.awk -v textidx=2 -v nogettext=1 -v prefix=GPG_ERR_ -v namespace=errnos_ ${CMAKE_CURRENT_SOURCE_DIR}/src/errnos.in > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/errnos-sym.h
+# )
+
+
+# ADD_EXECUTABLE(mkheader src/mkheader.c)
+# target_compile_definitions(mkheader
+#   PRIVATE
+#   HAVE_CONFIG_H
+#   _CRT_SECURE_NO_WARNINGS
+#   _CRT_NONSTDC_NO_WARNINGS)
+  
+# target_include_directories(mkheader
+#   PRIVATE
+#   $<BUILD_INTERFACE:.;cmake;src;${CMAKE_CURRENT_BINARY_DIR}>
+#   INTERFACE
+#   $<INSTALL_INTERFACE:include>
+# )
+  
+# add_custom_command(TARGET mkheader
+#   POST_BUILD
+#   COMMAND ${CMAKE_COMMAND} -E chdir ${CMAKE_CURRENT_SOURCE_DIR}/src $<TARGET_FILE:mkheader> "mingw32" "win32-msvc" "gpg-error.h.in" ${CMAKE_CURRENT_SOURCE_DIR}/cmake/config.h "1.27" "0x011b00" > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/gpg-error.h
+# )
+
+# ADD_EXECUTABLE(mkerrcodes src/mkerrcodes.c)
+# target_compile_definitions(mkerrcodes
+#   PRIVATE
+#   HAVE_CONFIG_H
+#   _CRT_SECURE_NO_WARNINGS
+#   _CRT_NONSTDC_NO_WARNINGS)
+  
+# target_include_directories(mkerrcodes
+#   PRIVATE
+#   $<BUILD_INTERFACE:.;cmake;src;${CMAKE_CURRENT_BINARY_DIR}>
+#   INTERFACE
+#   $<INSTALL_INTERFACE:include>
+# )
+
+# add_custom_command(
+#   TARGET mkerrcodes
+#   PRE_BUILD 
+#   COMMAND ${AWK} -f ${CMAKE_CURRENT_SOURCE_DIR}/src/mkerrcodes1.awk ${CMAKE_CURRENT_SOURCE_DIR}/src/errnos.in > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/_mkerrcodes.h
+#   COMMAND cl -E ${CMAKE_CURRENT_SOURCE_DIR}/cmake/_mkerrcodes.h | findstr GPG_ERR_ | \"${AWK}\" -f ${CMAKE_CURRENT_SOURCE_DIR}/src/mkerrcodes.awk > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/mkerrcodes.h
+#   COMMAND ${CMAKE_COMMAND} -E remove ${CMAKE_CURRENT_SOURCE_DIR}/cmake/_mkerrcodes.h
+# )
+
+# add_custom_command(
+#   TARGET mkerrcodes
+#   POST_BUILD 
+#   COMMAND $<TARGET_FILE:mkerrcodes> | \"${AWK}\" -f ${CMAKE_CURRENT_SOURCE_DIR}/src/mkerrcodes2.awk > ${CMAKE_CURRENT_SOURCE_DIR}/cmake/code-from-errno.h
+# )
+
+# add_dependencies(libgpg-error mkheader)
+# add_dependencies(libgpg-error mkerrcodes)
+
+include(CMakePackageConfigHelpers)
+write_basic_package_version_file(
+  ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake
+  VERSION ${PROJECT_VERSION}
+  COMPATIBILITY AnyNewerVersion
+)
+
+install(TARGETS ${PROJECT_NAME} EXPORT ${PROJECT_NAME}
+  RUNTIME DESTINATION bin
+  LIBRARY DESTINATION lib
+  ARCHIVE DESTINATION lib
+)
+
+install(FILES src/gpg-error.h DESTINATION include/)
+
+if(MSVC)
+  set_target_properties(libgpg-error
+    PROPERTIES
+      COMPILE_PDB_OUTPUT_DIRECTORY ${PROJECT_BINARY_DIR}
+      COMPILE_PDB_NAME libgpg-error
+      COMPILE_PDB_NAME_DEBUG libgpg-errord
+  )
+  install(FILES
+    ${PROJECT_BINARY_DIR}/RelWithDebInfo/libgpg-error.pdb
+    DESTINATION lib
+    CONFIGURATIONS RelWithDebInfo
+  )
+  install(FILES
+    ${PROJECT_BINARY_DIR}/Debug/libgpg-errord.pdb
+    DESTINATION lib
+    CONFIGURATIONS Debug
+  )
+endif()
+
+install(EXPORT ${PROJECT_NAME}
+  FILE
+    ${PROJECT_NAME}.cmake
+  NAMESPACE
+    ${PROJECT_NAME}::
+  DESTINATION
+    lib/cmake/${PROJECT_NAME}
+)
+
+install(
+  FILES
+    cmake/${PROJECT_NAME}-config.cmake
+    ${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}-config-version.cmake
+  DESTINATION
+    lib/cmake/${PROJECT_NAME}
+)
\ No newline at end of file
diff --git a/cmake/config.h b/cmake/config.h
new file mode 100644
index 0000000..9904342
--- /dev/null
+++ b/cmake/config.h
@@ -0,0 +1,203 @@
+
+/* Define to 1 if translation of program messages to the user's native
+   language is requested. */
+/* #undef ENABLE_NLS */
+
+/* Define to use the GNU C visibility attribute. */
+/* #undef GPGRT_USE_VISIBILITY */
+
+/* Define to 1 if you have the Mac OS X function CFLocaleCopyCurrent in the
+   CoreFoundation framework. */
+/* #undef HAVE_CFLOCALECOPYCURRENT */
+
+/* Define to 1 if you have the Mac OS X function CFPreferencesCopyAppValue in
+   the CoreFoundation framework. */
+/* #undef HAVE_CFPREFERENCESCOPYAPPVALUE */
+
+/* Define if the GNU dcgettext() function is already present or preinstalled.
+   */
+/* #undef HAVE_DCGETTEXT */
+
+/* Define to 1 if you have the declaration of `strerror_r', and to 0 if you
+   don't. */
+#define HAVE_DECL_STRERROR_R 0
+
+/* Define to 1 if you have the <dlfcn.h> header file. */
+/* #undef HAVE_DLFCN_H */
+
+/* Define to 1 if you have the `flockfile' function. */
+/* #undef HAVE_FLOCKFILE */
+
+/* Defined if a GCC style "__attribute__ ((aligned (n))" is supported */
+/* #undef HAVE_GCC_ATTRIBUTE_ALIGNED */
+
+/* Define if the GNU gettext() function is already present or preinstalled. */
+/* #undef HAVE_GETTEXT */
+
+/* Define if you have the iconv() function and it works. */
+#define HAVE_ICONV 1
+
+/* Define to 1 if the system has the type `intmax_t'. */
+#define HAVE_INTMAX_T 1
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#define HAVE_INTTYPES_H 1
+
+/* Define if you have <langinfo.h> and nl_langinfo(THOUSANDS_SEP). */
+/* #undef HAVE_LANGINFO_THOUSANDS_SEP */
+
+/* Define to 1 if you have the <locale.h> header file. */
+#define HAVE_LOCALE_H 1
+
+/* Define to 1 if the system has the type `long double'. */
+#define HAVE_LONG_DOUBLE 1
+
+/* Define to 1 if the system has the type 'long long int'. */
+#define HAVE_LONG_LONG_INT 1
+
+/* Define to 1 if you have the <memory.h> header file. */
+#define HAVE_MEMORY_H 1
+
+/* Define to 1 if you have the `memrchr' function. */
+/* #undef HAVE_MEMRCHR */
+
+/* Define if the <pthread.h> defines PTHREAD_MUTEX_RECURSIVE. */
+/* #undef HAVE_PTHREAD_MUTEX_RECURSIVE */
+
+/* Define if the POSIX multithreading library has read/write locks. */
+/* #undef HAVE_PTHREAD_RWLOCK */
+
+/* Define to 1 if the system has the type `ptrdiff_t'. */
+#define HAVE_PTRDIFF_T 1
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#define HAVE_STDINT_H 1
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#define HAVE_STDLIB_H 1
+
+/* Define to 1 if you have the `strerror_r' function. */
+/* #undef HAVE_STRERROR_R */
+
+/* Define to 1 if you have the <strings.h> header file. */
+/* #undef HAVE_STRINGS_H */
+
+/* Define to 1 if you have the <string.h> header file. */
+#define HAVE_STRING_H 1
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+/* #undef HAVE_SYS_SELECT_H */
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#define HAVE_SYS_STAT_H 1
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+/* #undef HAVE_SYS_TIME_H */
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#define HAVE_SYS_TYPES_H 1
+
+/* Define to 1 if the system has the type `uintmax_t'. */
+#define HAVE_UINTMAX_T 1
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#define HAVE_UNISTD_H 1
+
+/* Define to 1 if the system has the type 'unsigned long long int'. */
+#define HAVE_UNSIGNED_LONG_LONG_INT 1
+
+/* Define to 1 if you have the `vasprintf' function. */
+#define HAVE_VASPRINTF 1
+
+/* Defined if we run on WindowsCE */
+/* #undef HAVE_W32CE_SYSTEM */
+
+/* Defined if we run on a W32 API based system */
+#define HAVE_W32_SYSTEM 1
+
+/* Defined if we run on 64 bit W32 API system */
+#if defined(__x86_64) || defined(_M_X64)
+#define HAVE_W64_SYSTEM 1
+#endif
+
+/* Define to 1 if you have the <winsock2.h> header file. */
+#define HAVE_WINSOCK2_H 1;
+
+/* Name of package */
+#define PACKAGE "libgpg-error"
+
+/* Define to the full name of this package. */
+#define PACKAGE_NAME "libgpg-error"
+
+#include "version.h"
+
+/* Define if the pthread_in_use() detection is hard. */
+/* #undef PTHREAD_IN_USE_DETECTION_HARD */
+
+/* Used by mkheader to insert the replacement type. */
+#define REPLACEMENT_FOR_OFF_T "int64_t"
+
+/* The size of `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of `long', as computed by sizeof. */
+#define SIZEOF_LONG 4
+
+/* The size of `long long', as computed by sizeof. */
+#define SIZEOF_LONG_LONG 8
+
+/* The size of `pthread_mutex_t', as computed by sizeof. */
+/* #undef SIZEOF_PTHREAD_MUTEX_T */
+
+/* The size of `unsigned long', as computed by sizeof. */
+#define SIZEOF_UNSIGNED_LONG 4
+
+/* The size of `void *', as computed by sizeof. */
+#if defined(__x86_64) || defined(_M_X64)
+#define SIZEOF_VOID_P 8
+#else
+#define SIZEOF_VOID_P 4
+#endif
+
+/* Define to 1 if you have the ANSI C header files. */
+#define STDC_HEADERS 1
+
+/* Define to 1 if strerror_r returns char *. */
+/* #undef STRERROR_R_CHAR_P */
+
+/* Define if the POSIX multithreading library can be used. */
+/* #undef USE_POSIX_THREADS */
+
+/* Define if references to the POSIX multithreading library should be made
+   weak. */
+/* #undef USE_POSIX_THREADS_WEAK */
+
+/* Define if the old Solaris multithreading library can be used. */
+/* #undef USE_SOLARIS_THREADS */
+
+/* Define if references to the old Solaris multithreading library should be
+   made weak. */
+/* #undef USE_SOLARIS_THREADS_WEAK */
+
+
+/* Define if the native Windows multithreading API can be used. */
+#define USE_WINDOWS_THREADS 1
+
+#define HAVE_INET_PTON 1
+#define GPGRT_ENABLE_ARGPARSE_MACROS 1
+
+
+/* Force using of NLS for W32 even if no libintl has been found.  This is
+   okay because we have our own gettext implementation for W32.  */
+#if defined(HAVE_W32_SYSTEM) && !defined(ENABLE_NLS)
+#define ENABLE_NLS 1
+#endif
+
+/* Connect the generic estream-printf.c to our framework.  */
+#define _ESTREAM_PRINTF_REALLOC _gpgrt_realloc
+#define _ESTREAM_PRINTF_EXTRA_INCLUDE "gpgrt-int.h"
+
+/* For building we need to define these macro.  */
+#define GPG_ERR_ENABLE_GETTEXT_MACROS 1
+#define GPG_ERR_ENABLE_ERRNO_MACROS 1
+#define GPGRT_ENABLE_ES_MACROS 1
diff --git a/cmake/libgpg-error-config.cmake b/cmake/libgpg-error-config.cmake
new file mode 100644
index 0000000..16ae154
--- /dev/null
+++ b/cmake/libgpg-error-config.cmake
@@ -0,0 +1 @@
+include(${CMAKE_CURRENT_LIST_DIR}/libgpg-error.cmake)
\ No newline at end of file
diff --git a/cmake/libgpg-error.def b/cmake/libgpg-error.def
new file mode 100644
index 0000000..7706a40
--- /dev/null
+++ b/cmake/libgpg-error.def
@@ -0,0 +1,128 @@
+EXPORTS
+ gpg_strerror @1
+ gpg_strerror_r @2
+ gpg_strsource @3
+ gpg_err_code_from_errno @4
+ gpg_err_code_to_errno @5
+
+ gpg_err_code_from_syserror @7
+ gpg_err_set_errno @8
+
+
+
+
+
+ _gpg_w32_bindtextdomain @11
+ _gpg_w32_textdomain @12
+ _gpg_w32_gettext @13
+ _gpg_w32_dgettext @14
+ _gpg_w32_dngettext @15
+ _gpg_w32_gettext_localename @16
+ _gpg_w32_gettext_use_utf8 @17
+
+
+ gpg_error_check_version @19
+
+ gpgrt_lock_init @20
+ gpgrt_lock_lock @21
+ gpgrt_lock_unlock @22
+ gpgrt_lock_destroy @23
+ gpgrt_yield @24
+ gpgrt_lock_trylock @25
+
+ gpgrt_set_syscall_clamp @26
+
+ gpgrt_fopen @27
+ gpgrt_mopen @28
+ gpgrt_fopenmem @29
+ gpgrt_fopenmem_init @30
+ gpgrt_fdopen @31
+ gpgrt_fdopen_nc @32
+ gpgrt_sysopen @33
+ gpgrt_sysopen_nc @34
+ gpgrt_fpopen @35
+ gpgrt_fpopen_nc @36
+ gpgrt_freopen @37
+ gpgrt_fopencookie @38
+ gpgrt_fclose @39
+ gpgrt_fclose_snatch @40
+ gpgrt_onclose @41
+ gpgrt_fileno @42
+ gpgrt_fileno_unlocked @43
+ gpgrt_syshd @44
+ gpgrt_syshd_unlocked @45
+ _gpgrt_set_std_fd @46
+ _gpgrt_get_std_stream @47
+ gpgrt_flockfile @48
+ gpgrt_ftrylockfile @49
+ gpgrt_funlockfile @50
+ gpgrt_feof @51
+ gpgrt_feof_unlocked @52
+ gpgrt_ferror @53
+ gpgrt_ferror_unlocked @54
+ gpgrt_clearerr @55
+ gpgrt_clearerr_unlocked @56
+ gpgrt_fflush @57
+ gpgrt_fseek @58
+ gpgrt_fseeko @59
+ gpgrt_ftell @60
+ gpgrt_ftello @61
+ gpgrt_rewind @62
+ gpgrt_fgetc @63
+ _gpgrt_getc_underflow @64
+ gpgrt_fputc @65
+ _gpgrt_putc_overflow @66
+ gpgrt_ungetc @67
+ gpgrt_read @68
+ gpgrt_write @69
+ gpgrt_write_sanitized @70
+ gpgrt_write_hexstring @71
+ gpgrt_fread @72
+ gpgrt_fwrite @73
+ gpgrt_fgets @74
+ gpgrt_fputs @75
+ gpgrt_fputs_unlocked @76
+ gpgrt_getline @77
+ gpgrt_read_line @78
+ gpgrt_free @79
+ gpgrt_fprintf @80
+ gpgrt_fprintf_unlocked @81
+ gpgrt_printf @82
+ gpgrt_printf_unlocked @83
+ gpgrt_vfprintf @84
+ gpgrt_vfprintf_unlocked @85
+ gpgrt_setvbuf @86
+ gpgrt_setbuf @87
+ gpgrt_set_binary @88
+ gpgrt_tmpfile @89
+ gpgrt_opaque_set @90
+ gpgrt_opaque_get @91
+ gpgrt_fname_set @92
+ gpgrt_fname_get @93
+ gpgrt_asprintf @94
+ gpgrt_vasprintf @95
+ gpgrt_bsprintf @96
+ gpgrt_vbsprintf @97
+ gpgrt_snprintf @98
+ gpgrt_vsnprintf @99
+
+ gpgrt_check_version @100
+ gpg_err_init @101
+ gpg_err_deinit @102
+ gpgrt_set_alloc_func @103
+
+ _gpgrt_pending @104
+ _gpgrt_pending_unlocked @105
+
+ gpgrt_set_nonblock @106
+ gpgrt_get_nonblock @107
+ gpgrt_poll @108
+
+
+ gpgrt_get_syscall_clamp @112
+
+ gpgrt_b64dec_start @113
+ gpgrt_b64dec_proc @114
+ gpgrt_b64dec_finish @115
+
+;; end of file with public symbols for Windows.
\ No newline at end of file
diff --git a/cmake/version.h b/cmake/version.h
new file mode 100644
index 0000000..0918b5e
--- /dev/null
+++ b/cmake/version.h
@@ -0,0 +1,8 @@
+/* Define to the version of this package. */
+#define PACKAGE_VERSION "1.36"
+
+/* GIT commit id revision used to build this package */
+#define BUILD_REVISION "8956a7b"
+
+/* The time this package was configured for a build */
+#define BUILD_TIMESTAMP "2019-12-02"
\ No newline at end of file
diff --git a/src/code-from-errno.h b/src/code-from-errno.h
new file mode 100644
index 0000000..8730ff0
--- /dev/null
+++ b/src/code-from-errno.h
@@ -0,0 +1,158 @@
+/* Output of mkerrcodes2.awk.  DO NOT EDIT.  */
+
+/* errnos.h - List of system error values.
+   Copyright (C) 2004 g10 Code GmbH
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+static const int err_code_from_index[] = {
+  GPG_ERR_EPERM,
+  GPG_ERR_ENOENT,
+  GPG_ERR_ESRCH,
+  GPG_ERR_EINTR,
+  GPG_ERR_EIO,
+  GPG_ERR_ENXIO,
+  GPG_ERR_E2BIG,
+  GPG_ERR_ENOEXEC,
+  GPG_ERR_EBADF,
+  GPG_ERR_ECHILD,
+  GPG_ERR_EAGAIN,
+  GPG_ERR_EWOULDBLOCK,
+  GPG_ERR_ENOMEM,
+  GPG_ERR_EACCES,
+  GPG_ERR_EFAULT,
+  GPG_ERR_ENOTBLK,
+  GPG_ERR_EBUSY,
+  GPG_ERR_EEXIST,
+  GPG_ERR_EXDEV,
+  GPG_ERR_ENODEV,
+  GPG_ERR_ENOTDIR,
+  GPG_ERR_EISDIR,
+  GPG_ERR_EINVAL,
+  GPG_ERR_ENFILE,
+  GPG_ERR_EMFILE,
+  GPG_ERR_ENOTTY,
+  GPG_ERR_ETXTBSY,
+  GPG_ERR_EFBIG,
+  GPG_ERR_ENOSPC,
+  GPG_ERR_ESPIPE,
+  GPG_ERR_EROFS,
+  GPG_ERR_EMLINK,
+  GPG_ERR_EPIPE,
+  GPG_ERR_EDOM,
+  GPG_ERR_ERANGE,
+  GPG_ERR_EDEADLK,
+  GPG_ERR_EDEADLOCK,
+  GPG_ERR_ENAMETOOLONG,
+  GPG_ERR_ENOLCK,
+  GPG_ERR_ENOSYS,
+  GPG_ERR_ENOTEMPTY,
+  GPG_ERR_ELOOP,
+  GPG_ERR_ENOMSG,
+  GPG_ERR_EIDRM,
+  GPG_ERR_ECHRNG,
+  GPG_ERR_EL2NSYNC,
+  GPG_ERR_EL3HLT,
+  GPG_ERR_EL3RST,
+  GPG_ERR_ELNRNG,
+  GPG_ERR_EUNATCH,
+  GPG_ERR_ENOCSI,
+  GPG_ERR_EL2HLT,
+  GPG_ERR_EBADE,
+  GPG_ERR_EBADR,
+  GPG_ERR_EXFULL,
+  GPG_ERR_ENOANO,
+  GPG_ERR_EBADRQC,
+  GPG_ERR_EBADSLT,
+  GPG_ERR_EBFONT,
+  GPG_ERR_ENOSTR,
+  GPG_ERR_ENODATA,
+  GPG_ERR_ETIME,
+  GPG_ERR_ENOSR,
+  GPG_ERR_ENONET,
+  GPG_ERR_ENOPKG,
+  GPG_ERR_EREMOTE,
+  GPG_ERR_ENOLINK,
+  GPG_ERR_EADV,
+  GPG_ERR_ESRMNT,
+  GPG_ERR_ECOMM,
+  GPG_ERR_EPROTO,
+  GPG_ERR_EMULTIHOP,
+  GPG_ERR_EDOTDOT,
+  GPG_ERR_EBADMSG,
+  GPG_ERR_EOVERFLOW,
+  GPG_ERR_ENOTUNIQ,
+  GPG_ERR_EBADFD,
+  GPG_ERR_EREMCHG,
+  GPG_ERR_ELIBACC,
+  GPG_ERR_ELIBBAD,
+  GPG_ERR_ELIBSCN,
+  GPG_ERR_ELIBMAX,
+  GPG_ERR_ELIBEXEC,
+  GPG_ERR_EILSEQ,
+  GPG_ERR_ERESTART,
+  GPG_ERR_ESTRPIPE,
+  GPG_ERR_EUSERS,
+  GPG_ERR_ENOTSOCK,
+  GPG_ERR_EDESTADDRREQ,
+  GPG_ERR_EMSGSIZE,
+  GPG_ERR_EPROTOTYPE,
+  GPG_ERR_ENOPROTOOPT,
+  GPG_ERR_EPROTONOSUPPORT,
+  GPG_ERR_ESOCKTNOSUPPORT,
+  GPG_ERR_ENOTSUP,
+  GPG_ERR_EOPNOTSUPP,
+  GPG_ERR_EPFNOSUPPORT,
+  GPG_ERR_EAFNOSUPPORT,
+  GPG_ERR_EADDRINUSE,
+  GPG_ERR_EADDRNOTAVAIL,
+  GPG_ERR_ENETDOWN,
+  GPG_ERR_ENETUNREACH,
+  GPG_ERR_ENETRESET,
+  GPG_ERR_ECONNABORTED,
+  GPG_ERR_ECONNRESET,
+  GPG_ERR_ENOBUFS,
+  GPG_ERR_EISCONN,
+  GPG_ERR_ENOTCONN,
+  GPG_ERR_ESHUTDOWN,
+  GPG_ERR_ETOOMANYREFS,
+  GPG_ERR_ETIMEDOUT,
+  GPG_ERR_ECONNREFUSED,
+  GPG_ERR_EHOSTDOWN,
+  GPG_ERR_EHOSTUNREACH,
+  GPG_ERR_EALREADY,
+  GPG_ERR_EINPROGRESS,
+  GPG_ERR_ESTALE,
+  GPG_ERR_EUCLEAN,
+  GPG_ERR_ENOTNAM,
+  GPG_ERR_ENAVAIL,
+  GPG_ERR_EISNAM,
+  GPG_ERR_EREMOTEIO,
+  GPG_ERR_EDQUOT,
+  GPG_ERR_ENOMEDIUM,
+  GPG_ERR_EMEDIUMTYPE,
+  GPG_ERR_ECANCELED,
+};
+
+#define errno_to_idx(code) (0 ? -1 \
+  : ((code >= 1) && (code <= 11)) ? (code - 1) \
+  : ((code >= 11) && (code <= 35)) ? (code - 0) \
+  : ((code >= 35) && (code <= 40)) ? (code - -1) \
+  : ((code >= 42) && (code <= 57)) ? (code - 0) \
+  : ((code >= 59) && (code <= 95)) ? (code - 1) \
+  : ((code >= 95) && (code <= 125)) ? (code - 0) \
+  : -1)
diff --git a/src/code-to-errno.h b/src/code-to-errno.h
new file mode 100644
index 0000000..8907fc0
--- /dev/null
+++ b/src/code-to-errno.h
@@ -0,0 +1,1300 @@
+/* Output of mkerrnos.awk.  DO NOT EDIT.  */
+
+/* errnos.in - List of system error values.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+
+#include <errno.h>
+#ifdef _WIN32
+#include <winsock2.h>
+#endif
+
+static const int err_code_to_errno [] = {
+#ifdef E2BIG
+  E2BIG,
+#else
+#ifdef WSAE2BIG
+  WSAE2BIG,
+#else
+  0,
+#endif
+#endif
+#ifdef EACCES
+  EACCES,
+#else
+#ifdef WSAEACCES
+  WSAEACCES,
+#else
+  0,
+#endif
+#endif
+#ifdef EADDRINUSE
+  EADDRINUSE,
+#else
+#ifdef WSAEADDRINUSE
+  WSAEADDRINUSE,
+#else
+  0,
+#endif
+#endif
+#ifdef EADDRNOTAVAIL
+  EADDRNOTAVAIL,
+#else
+#ifdef WSAEADDRNOTAVAIL
+  WSAEADDRNOTAVAIL,
+#else
+  0,
+#endif
+#endif
+#ifdef EADV
+  EADV,
+#else
+#ifdef WSAEADV
+  WSAEADV,
+#else
+  0,
+#endif
+#endif
+#ifdef EAFNOSUPPORT
+  EAFNOSUPPORT,
+#else
+#ifdef WSAEAFNOSUPPORT
+  WSAEAFNOSUPPORT,
+#else
+  0,
+#endif
+#endif
+#ifdef EAGAIN
+  EAGAIN,
+#else
+#ifdef WSAEAGAIN
+  WSAEAGAIN,
+#else
+  0,
+#endif
+#endif
+#ifdef EALREADY
+  EALREADY,
+#else
+#ifdef WSAEALREADY
+  WSAEALREADY,
+#else
+  0,
+#endif
+#endif
+#ifdef EAUTH
+  EAUTH,
+#else
+#ifdef WSAEAUTH
+  WSAEAUTH,
+#else
+  0,
+#endif
+#endif
+#ifdef EBACKGROUND
+  EBACKGROUND,
+#else
+#ifdef WSAEBACKGROUND
+  WSAEBACKGROUND,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADE
+  EBADE,
+#else
+#ifdef WSAEBADE
+  WSAEBADE,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADF
+  EBADF,
+#else
+#ifdef WSAEBADF
+  WSAEBADF,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADFD
+  EBADFD,
+#else
+#ifdef WSAEBADFD
+  WSAEBADFD,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADMSG
+  EBADMSG,
+#else
+#ifdef WSAEBADMSG
+  WSAEBADMSG,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADR
+  EBADR,
+#else
+#ifdef WSAEBADR
+  WSAEBADR,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADRPC
+  EBADRPC,
+#else
+#ifdef WSAEBADRPC
+  WSAEBADRPC,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADRQC
+  EBADRQC,
+#else
+#ifdef WSAEBADRQC
+  WSAEBADRQC,
+#else
+  0,
+#endif
+#endif
+#ifdef EBADSLT
+  EBADSLT,
+#else
+#ifdef WSAEBADSLT
+  WSAEBADSLT,
+#else
+  0,
+#endif
+#endif
+#ifdef EBFONT
+  EBFONT,
+#else
+#ifdef WSAEBFONT
+  WSAEBFONT,
+#else
+  0,
+#endif
+#endif
+#ifdef EBUSY
+  EBUSY,
+#else
+#ifdef WSAEBUSY
+  WSAEBUSY,
+#else
+  0,
+#endif
+#endif
+#ifdef ECANCELED
+  ECANCELED,
+#else
+#ifdef WSAECANCELED
+  WSAECANCELED,
+#else
+  0,
+#endif
+#endif
+#ifdef ECHILD
+  ECHILD,
+#else
+#ifdef WSAECHILD
+  WSAECHILD,
+#else
+  0,
+#endif
+#endif
+#ifdef ECHRNG
+  ECHRNG,
+#else
+#ifdef WSAECHRNG
+  WSAECHRNG,
+#else
+  0,
+#endif
+#endif
+#ifdef ECOMM
+  ECOMM,
+#else
+#ifdef WSAECOMM
+  WSAECOMM,
+#else
+  0,
+#endif
+#endif
+#ifdef ECONNABORTED
+  ECONNABORTED,
+#else
+#ifdef WSAECONNABORTED
+  WSAECONNABORTED,
+#else
+  0,
+#endif
+#endif
+#ifdef ECONNREFUSED
+  ECONNREFUSED,
+#else
+#ifdef WSAECONNREFUSED
+  WSAECONNREFUSED,
+#else
+  0,
+#endif
+#endif
+#ifdef ECONNRESET
+  ECONNRESET,
+#else
+#ifdef WSAECONNRESET
+  WSAECONNRESET,
+#else
+  0,
+#endif
+#endif
+#ifdef ED
+  ED,
+#else
+#ifdef WSAED
+  WSAED,
+#else
+  0,
+#endif
+#endif
+#ifdef EDEADLK
+  EDEADLK,
+#else
+#ifdef WSAEDEADLK
+  WSAEDEADLK,
+#else
+  0,
+#endif
+#endif
+#ifdef EDEADLOCK
+  EDEADLOCK,
+#else
+#ifdef WSAEDEADLOCK
+  WSAEDEADLOCK,
+#else
+  0,
+#endif
+#endif
+#ifdef EDESTADDRREQ
+  EDESTADDRREQ,
+#else
+#ifdef WSAEDESTADDRREQ
+  WSAEDESTADDRREQ,
+#else
+  0,
+#endif
+#endif
+#ifdef EDIED
+  EDIED,
+#else
+#ifdef WSAEDIED
+  WSAEDIED,
+#else
+  0,
+#endif
+#endif
+#ifdef EDOM
+  EDOM,
+#else
+#ifdef WSAEDOM
+  WSAEDOM,
+#else
+  0,
+#endif
+#endif
+#ifdef EDOTDOT
+  EDOTDOT,
+#else
+#ifdef WSAEDOTDOT
+  WSAEDOTDOT,
+#else
+  0,
+#endif
+#endif
+#ifdef EDQUOT
+  EDQUOT,
+#else
+#ifdef WSAEDQUOT
+  WSAEDQUOT,
+#else
+  0,
+#endif
+#endif
+#ifdef EEXIST
+  EEXIST,
+#else
+#ifdef WSAEEXIST
+  WSAEEXIST,
+#else
+  0,
+#endif
+#endif
+#ifdef EFAULT
+  EFAULT,
+#else
+#ifdef WSAEFAULT
+  WSAEFAULT,
+#else
+  0,
+#endif
+#endif
+#ifdef EFBIG
+  EFBIG,
+#else
+#ifdef WSAEFBIG
+  WSAEFBIG,
+#else
+  0,
+#endif
+#endif
+#ifdef EFTYPE
+  EFTYPE,
+#else
+#ifdef WSAEFTYPE
+  WSAEFTYPE,
+#else
+  0,
+#endif
+#endif
+#ifdef EGRATUITOUS
+  EGRATUITOUS,
+#else
+#ifdef WSAEGRATUITOUS
+  WSAEGRATUITOUS,
+#else
+  0,
+#endif
+#endif
+#ifdef EGREGIOUS
+  EGREGIOUS,
+#else
+#ifdef WSAEGREGIOUS
+  WSAEGREGIOUS,
+#else
+  0,
+#endif
+#endif
+#ifdef EHOSTDOWN
+  EHOSTDOWN,
+#else
+#ifdef WSAEHOSTDOWN
+  WSAEHOSTDOWN,
+#else
+  0,
+#endif
+#endif
+#ifdef EHOSTUNREACH
+  EHOSTUNREACH,
+#else
+#ifdef WSAEHOSTUNREACH
+  WSAEHOSTUNREACH,
+#else
+  0,
+#endif
+#endif
+#ifdef EIDRM
+  EIDRM,
+#else
+#ifdef WSAEIDRM
+  WSAEIDRM,
+#else
+  0,
+#endif
+#endif
+#ifdef EIEIO
+  EIEIO,
+#else
+#ifdef WSAEIEIO
+  WSAEIEIO,
+#else
+  0,
+#endif
+#endif
+#ifdef EILSEQ
+  EILSEQ,
+#else
+#ifdef WSAEILSEQ
+  WSAEILSEQ,
+#else
+  0,
+#endif
+#endif
+#ifdef EINPROGRESS
+  EINPROGRESS,
+#else
+#ifdef WSAEINPROGRESS
+  WSAEINPROGRESS,
+#else
+  0,
+#endif
+#endif
+#ifdef EINTR
+  EINTR,
+#else
+#ifdef WSAEINTR
+  WSAEINTR,
+#else
+  0,
+#endif
+#endif
+#ifdef EINVAL
+  EINVAL,
+#else
+#ifdef WSAEINVAL
+  WSAEINVAL,
+#else
+  0,
+#endif
+#endif
+#ifdef EIO
+  EIO,
+#else
+#ifdef WSAEIO
+  WSAEIO,
+#else
+  0,
+#endif
+#endif
+#ifdef EISCONN
+  EISCONN,
+#else
+#ifdef WSAEISCONN
+  WSAEISCONN,
+#else
+  0,
+#endif
+#endif
+#ifdef EISDIR
+  EISDIR,
+#else
+#ifdef WSAEISDIR
+  WSAEISDIR,
+#else
+  0,
+#endif
+#endif
+#ifdef EISNAM
+  EISNAM,
+#else
+#ifdef WSAEISNAM
+  WSAEISNAM,
+#else
+  0,
+#endif
+#endif
+#ifdef EL2HLT
+  EL2HLT,
+#else
+#ifdef WSAEL2HLT
+  WSAEL2HLT,
+#else
+  0,
+#endif
+#endif
+#ifdef EL2NSYNC
+  EL2NSYNC,
+#else
+#ifdef WSAEL2NSYNC
+  WSAEL2NSYNC,
+#else
+  0,
+#endif
+#endif
+#ifdef EL3HLT
+  EL3HLT,
+#else
+#ifdef WSAEL3HLT
+  WSAEL3HLT,
+#else
+  0,
+#endif
+#endif
+#ifdef EL3RST
+  EL3RST,
+#else
+#ifdef WSAEL3RST
+  WSAEL3RST,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBACC
+  ELIBACC,
+#else
+#ifdef WSAELIBACC
+  WSAELIBACC,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBBAD
+  ELIBBAD,
+#else
+#ifdef WSAELIBBAD
+  WSAELIBBAD,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBEXEC
+  ELIBEXEC,
+#else
+#ifdef WSAELIBEXEC
+  WSAELIBEXEC,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBMAX
+  ELIBMAX,
+#else
+#ifdef WSAELIBMAX
+  WSAELIBMAX,
+#else
+  0,
+#endif
+#endif
+#ifdef ELIBSCN
+  ELIBSCN,
+#else
+#ifdef WSAELIBSCN
+  WSAELIBSCN,
+#else
+  0,
+#endif
+#endif
+#ifdef ELNRNG
+  ELNRNG,
+#else
+#ifdef WSAELNRNG
+  WSAELNRNG,
+#else
+  0,
+#endif
+#endif
+#ifdef ELOOP
+  ELOOP,
+#else
+#ifdef WSAELOOP
+  WSAELOOP,
+#else
+  0,
+#endif
+#endif
+#ifdef EMEDIUMTYPE
+  EMEDIUMTYPE,
+#else
+#ifdef WSAEMEDIUMTYPE
+  WSAEMEDIUMTYPE,
+#else
+  0,
+#endif
+#endif
+#ifdef EMFILE
+  EMFILE,
+#else
+#ifdef WSAEMFILE
+  WSAEMFILE,
+#else
+  0,
+#endif
+#endif
+#ifdef EMLINK
+  EMLINK,
+#else
+#ifdef WSAEMLINK
+  WSAEMLINK,
+#else
+  0,
+#endif
+#endif
+#ifdef EMSGSIZE
+  EMSGSIZE,
+#else
+#ifdef WSAEMSGSIZE
+  WSAEMSGSIZE,
+#else
+  0,
+#endif
+#endif
+#ifdef EMULTIHOP
+  EMULTIHOP,
+#else
+#ifdef WSAEMULTIHOP
+  WSAEMULTIHOP,
+#else
+  0,
+#endif
+#endif
+#ifdef ENAMETOOLONG
+  ENAMETOOLONG,
+#else
+#ifdef WSAENAMETOOLONG
+  WSAENAMETOOLONG,
+#else
+  0,
+#endif
+#endif
+#ifdef ENAVAIL
+  ENAVAIL,
+#else
+#ifdef WSAENAVAIL
+  WSAENAVAIL,
+#else
+  0,
+#endif
+#endif
+#ifdef ENEEDAUTH
+  ENEEDAUTH,
+#else
+#ifdef WSAENEEDAUTH
+  WSAENEEDAUTH,
+#else
+  0,
+#endif
+#endif
+#ifdef ENETDOWN
+  ENETDOWN,
+#else
+#ifdef WSAENETDOWN
+  WSAENETDOWN,
+#else
+  0,
+#endif
+#endif
+#ifdef ENETRESET
+  ENETRESET,
+#else
+#ifdef WSAENETRESET
+  WSAENETRESET,
+#else
+  0,
+#endif
+#endif
+#ifdef ENETUNREACH
+  ENETUNREACH,
+#else
+#ifdef WSAENETUNREACH
+  WSAENETUNREACH,
+#else
+  0,
+#endif
+#endif
+#ifdef ENFILE
+  ENFILE,
+#else
+#ifdef WSAENFILE
+  WSAENFILE,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOANO
+  ENOANO,
+#else
+#ifdef WSAENOANO
+  WSAENOANO,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOBUFS
+  ENOBUFS,
+#else
+#ifdef WSAENOBUFS
+  WSAENOBUFS,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOCSI
+  ENOCSI,
+#else
+#ifdef WSAENOCSI
+  WSAENOCSI,
+#else
+  0,
+#endif
+#endif
+#ifdef ENODATA
+  ENODATA,
+#else
+#ifdef WSAENODATA
+  WSAENODATA,
+#else
+  0,
+#endif
+#endif
+#ifdef ENODEV
+  ENODEV,
+#else
+#ifdef WSAENODEV
+  WSAENODEV,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOENT
+  ENOENT,
+#else
+#ifdef WSAENOENT
+  WSAENOENT,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOEXEC
+  ENOEXEC,
+#else
+#ifdef WSAENOEXEC
+  WSAENOEXEC,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOLCK
+  ENOLCK,
+#else
+#ifdef WSAENOLCK
+  WSAENOLCK,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOLINK
+  ENOLINK,
+#else
+#ifdef WSAENOLINK
+  WSAENOLINK,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOMEDIUM
+  ENOMEDIUM,
+#else
+#ifdef WSAENOMEDIUM
+  WSAENOMEDIUM,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOMEM
+  ENOMEM,
+#else
+#ifdef WSAENOMEM
+  WSAENOMEM,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOMSG
+  ENOMSG,
+#else
+#ifdef WSAENOMSG
+  WSAENOMSG,
+#else
+  0,
+#endif
+#endif
+#ifdef ENONET
+  ENONET,
+#else
+#ifdef WSAENONET
+  WSAENONET,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOPKG
+  ENOPKG,
+#else
+#ifdef WSAENOPKG
+  WSAENOPKG,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOPROTOOPT
+  ENOPROTOOPT,
+#else
+#ifdef WSAENOPROTOOPT
+  WSAENOPROTOOPT,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOSPC
+  ENOSPC,
+#else
+#ifdef WSAENOSPC
+  WSAENOSPC,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOSR
+  ENOSR,
+#else
+#ifdef WSAENOSR
+  WSAENOSR,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOSTR
+  ENOSTR,
+#else
+#ifdef WSAENOSTR
+  WSAENOSTR,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOSYS
+  ENOSYS,
+#else
+#ifdef WSAENOSYS
+  WSAENOSYS,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTBLK
+  ENOTBLK,
+#else
+#ifdef WSAENOTBLK
+  WSAENOTBLK,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTCONN
+  ENOTCONN,
+#else
+#ifdef WSAENOTCONN
+  WSAENOTCONN,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTDIR
+  ENOTDIR,
+#else
+#ifdef WSAENOTDIR
+  WSAENOTDIR,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTEMPTY
+  ENOTEMPTY,
+#else
+#ifdef WSAENOTEMPTY
+  WSAENOTEMPTY,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTNAM
+  ENOTNAM,
+#else
+#ifdef WSAENOTNAM
+  WSAENOTNAM,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTSOCK
+  ENOTSOCK,
+#else
+#ifdef WSAENOTSOCK
+  WSAENOTSOCK,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTSUP
+  ENOTSUP,
+#else
+#ifdef WSAENOTSUP
+  WSAENOTSUP,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTTY
+  ENOTTY,
+#else
+#ifdef WSAENOTTY
+  WSAENOTTY,
+#else
+  0,
+#endif
+#endif
+#ifdef ENOTUNIQ
+  ENOTUNIQ,
+#else
+#ifdef WSAENOTUNIQ
+  WSAENOTUNIQ,
+#else
+  0,
+#endif
+#endif
+#ifdef ENXIO
+  ENXIO,
+#else
+#ifdef WSAENXIO
+  WSAENXIO,
+#else
+  0,
+#endif
+#endif
+#ifdef EOPNOTSUPP
+  EOPNOTSUPP,
+#else
+#ifdef WSAEOPNOTSUPP
+  WSAEOPNOTSUPP,
+#else
+  0,
+#endif
+#endif
+#ifdef EOVERFLOW
+  EOVERFLOW,
+#else
+#ifdef WSAEOVERFLOW
+  WSAEOVERFLOW,
+#else
+  0,
+#endif
+#endif
+#ifdef EPERM
+  EPERM,
+#else
+#ifdef WSAEPERM
+  WSAEPERM,
+#else
+  0,
+#endif
+#endif
+#ifdef EPFNOSUPPORT
+  EPFNOSUPPORT,
+#else
+#ifdef WSAEPFNOSUPPORT
+  WSAEPFNOSUPPORT,
+#else
+  0,
+#endif
+#endif
+#ifdef EPIPE
+  EPIPE,
+#else
+#ifdef WSAEPIPE
+  WSAEPIPE,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROCLIM
+  EPROCLIM,
+#else
+#ifdef WSAEPROCLIM
+  WSAEPROCLIM,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROCUNAVAIL
+  EPROCUNAVAIL,
+#else
+#ifdef WSAEPROCUNAVAIL
+  WSAEPROCUNAVAIL,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROGMISMATCH
+  EPROGMISMATCH,
+#else
+#ifdef WSAEPROGMISMATCH
+  WSAEPROGMISMATCH,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROGUNAVAIL
+  EPROGUNAVAIL,
+#else
+#ifdef WSAEPROGUNAVAIL
+  WSAEPROGUNAVAIL,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROTO
+  EPROTO,
+#else
+#ifdef WSAEPROTO
+  WSAEPROTO,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROTONOSUPPORT
+  EPROTONOSUPPORT,
+#else
+#ifdef WSAEPROTONOSUPPORT
+  WSAEPROTONOSUPPORT,
+#else
+  0,
+#endif
+#endif
+#ifdef EPROTOTYPE
+  EPROTOTYPE,
+#else
+#ifdef WSAEPROTOTYPE
+  WSAEPROTOTYPE,
+#else
+  0,
+#endif
+#endif
+#ifdef ERANGE
+  ERANGE,
+#else
+#ifdef WSAERANGE
+  WSAERANGE,
+#else
+  0,
+#endif
+#endif
+#ifdef EREMCHG
+  EREMCHG,
+#else
+#ifdef WSAEREMCHG
+  WSAEREMCHG,
+#else
+  0,
+#endif
+#endif
+#ifdef EREMOTE
+  EREMOTE,
+#else
+#ifdef WSAEREMOTE
+  WSAEREMOTE,
+#else
+  0,
+#endif
+#endif
+#ifdef EREMOTEIO
+  EREMOTEIO,
+#else
+#ifdef WSAEREMOTEIO
+  WSAEREMOTEIO,
+#else
+  0,
+#endif
+#endif
+#ifdef ERESTART
+  ERESTART,
+#else
+#ifdef WSAERESTART
+  WSAERESTART,
+#else
+  0,
+#endif
+#endif
+#ifdef EROFS
+  EROFS,
+#else
+#ifdef WSAEROFS
+  WSAEROFS,
+#else
+  0,
+#endif
+#endif
+#ifdef ERPCMISMATCH
+  ERPCMISMATCH,
+#else
+#ifdef WSAERPCMISMATCH
+  WSAERPCMISMATCH,
+#else
+  0,
+#endif
+#endif
+#ifdef ESHUTDOWN
+  ESHUTDOWN,
+#else
+#ifdef WSAESHUTDOWN
+  WSAESHUTDOWN,
+#else
+  0,
+#endif
+#endif
+#ifdef ESOCKTNOSUPPORT
+  ESOCKTNOSUPPORT,
+#else
+#ifdef WSAESOCKTNOSUPPORT
+  WSAESOCKTNOSUPPORT,
+#else
+  0,
+#endif
+#endif
+#ifdef ESPIPE
+  ESPIPE,
+#else
+#ifdef WSAESPIPE
+  WSAESPIPE,
+#else
+  0,
+#endif
+#endif
+#ifdef ESRCH
+  ESRCH,
+#else
+#ifdef WSAESRCH
+  WSAESRCH,
+#else
+  0,
+#endif
+#endif
+#ifdef ESRMNT
+  ESRMNT,
+#else
+#ifdef WSAESRMNT
+  WSAESRMNT,
+#else
+  0,
+#endif
+#endif
+#ifdef ESTALE
+  ESTALE,
+#else
+#ifdef WSAESTALE
+  WSAESTALE,
+#else
+  0,
+#endif
+#endif
+#ifdef ESTRPIPE
+  ESTRPIPE,
+#else
+#ifdef WSAESTRPIPE
+  WSAESTRPIPE,
+#else
+  0,
+#endif
+#endif
+#ifdef ETIME
+  ETIME,
+#else
+#ifdef WSAETIME
+  WSAETIME,
+#else
+  0,
+#endif
+#endif
+#ifdef ETIMEDOUT
+  ETIMEDOUT,
+#else
+#ifdef WSAETIMEDOUT
+  WSAETIMEDOUT,
+#else
+  0,
+#endif
+#endif
+#ifdef ETOOMANYREFS
+  ETOOMANYREFS,
+#else
+#ifdef WSAETOOMANYREFS
+  WSAETOOMANYREFS,
+#else
+  0,
+#endif
+#endif
+#ifdef ETXTBSY
+  ETXTBSY,
+#else
+#ifdef WSAETXTBSY
+  WSAETXTBSY,
+#else
+  0,
+#endif
+#endif
+#ifdef EUCLEAN
+  EUCLEAN,
+#else
+#ifdef WSAEUCLEAN
+  WSAEUCLEAN,
+#else
+  0,
+#endif
+#endif
+#ifdef EUNATCH
+  EUNATCH,
+#else
+#ifdef WSAEUNATCH
+  WSAEUNATCH,
+#else
+  0,
+#endif
+#endif
+#ifdef EUSERS
+  EUSERS,
+#else
+#ifdef WSAEUSERS
+  WSAEUSERS,
+#else
+  0,
+#endif
+#endif
+#ifdef EWOULDBLOCK
+  EWOULDBLOCK,
+#else
+#ifdef WSAEWOULDBLOCK
+  WSAEWOULDBLOCK,
+#else
+  0,
+#endif
+#endif
+#ifdef EXDEV
+  EXDEV,
+#else
+#ifdef WSAEXDEV
+  WSAEXDEV,
+#else
+  0,
+#endif
+#endif
+#ifdef EXFULL
+  EXFULL,
+#else
+#ifdef WSAEXFULL
+  WSAEXFULL,
+#else
+  0,
+#endif
+#endif
+};
diff --git a/src/err-codes-sym.h b/src/err-codes-sym.h
new file mode 100644
index 0000000..20241d4
--- /dev/null
+++ b/src/err-codes-sym.h
@@ -0,0 +1,864 @@
+/* Output of mkstrtable.awk.  DO NOT EDIT.  */
+
+/* err-codes.h - List of error codes and their description.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+/* The purpose of this complex string table is to produce
+   optimal code with a minimum of relocations.  */
+
+static const char msgstr[] = 
+  "GPG_ERR_NO_ERROR" "\0"
+  "GPG_ERR_GENERAL" "\0"
+  "GPG_ERR_UNKNOWN_PACKET" "\0"
+  "GPG_ERR_UNKNOWN_VERSION" "\0"
+  "GPG_ERR_PUBKEY_ALGO" "\0"
+  "GPG_ERR_DIGEST_ALGO" "\0"
+  "GPG_ERR_BAD_PUBKEY" "\0"
+  "GPG_ERR_BAD_SECKEY" "\0"
+  "GPG_ERR_BAD_SIGNATURE" "\0"
+  "GPG_ERR_NO_PUBKEY" "\0"
+  "GPG_ERR_CHECKSUM" "\0"
+  "GPG_ERR_BAD_PASSPHRASE" "\0"
+  "GPG_ERR_CIPHER_ALGO" "\0"
+  "GPG_ERR_KEYRING_OPEN" "\0"
+  "GPG_ERR_INV_PACKET" "\0"
+  "GPG_ERR_INV_ARMOR" "\0"
+  "GPG_ERR_NO_USER_ID" "\0"
+  "GPG_ERR_NO_SECKEY" "\0"
+  "GPG_ERR_WRONG_SECKEY" "\0"
+  "GPG_ERR_BAD_KEY" "\0"
+  "GPG_ERR_COMPR_ALGO" "\0"
+  "GPG_ERR_NO_PRIME" "\0"
+  "GPG_ERR_NO_ENCODING_METHOD" "\0"
+  "GPG_ERR_NO_ENCRYPTION_SCHEME" "\0"
+  "GPG_ERR_NO_SIGNATURE_SCHEME" "\0"
+  "GPG_ERR_INV_ATTR" "\0"
+  "GPG_ERR_NO_VALUE" "\0"
+  "GPG_ERR_NOT_FOUND" "\0"
+  "GPG_ERR_VALUE_NOT_FOUND" "\0"
+  "GPG_ERR_SYNTAX" "\0"
+  "GPG_ERR_BAD_MPI" "\0"
+  "GPG_ERR_INV_PASSPHRASE" "\0"
+  "GPG_ERR_SIG_CLASS" "\0"
+  "GPG_ERR_RESOURCE_LIMIT" "\0"
+  "GPG_ERR_INV_KEYRING" "\0"
+  "GPG_ERR_TRUSTDB" "\0"
+  "GPG_ERR_BAD_CERT" "\0"
+  "GPG_ERR_INV_USER_ID" "\0"
+  "GPG_ERR_UNEXPECTED" "\0"
+  "GPG_ERR_TIME_CONFLICT" "\0"
+  "GPG_ERR_KEYSERVER" "\0"
+  "GPG_ERR_WRONG_PUBKEY_ALGO" "\0"
+  "GPG_ERR_TRIBUTE_TO_D_A" "\0"
+  "GPG_ERR_WEAK_KEY" "\0"
+  "GPG_ERR_INV_KEYLEN" "\0"
+  "GPG_ERR_INV_ARG" "\0"
+  "GPG_ERR_BAD_URI" "\0"
+  "GPG_ERR_INV_URI" "\0"
+  "GPG_ERR_NETWORK" "\0"
+  "GPG_ERR_UNKNOWN_HOST" "\0"
+  "GPG_ERR_SELFTEST_FAILED" "\0"
+  "GPG_ERR_NOT_ENCRYPTED" "\0"
+  "GPG_ERR_NOT_PROCESSED" "\0"
+  "GPG_ERR_UNUSABLE_PUBKEY" "\0"
+  "GPG_ERR_UNUSABLE_SECKEY" "\0"
+  "GPG_ERR_INV_VALUE" "\0"
+  "GPG_ERR_BAD_CERT_CHAIN" "\0"
+  "GPG_ERR_MISSING_CERT" "\0"
+  "GPG_ERR_NO_DATA" "\0"
+  "GPG_ERR_BUG" "\0"
+  "GPG_ERR_NOT_SUPPORTED" "\0"
+  "GPG_ERR_INV_OP" "\0"
+  "GPG_ERR_TIMEOUT" "\0"
+  "GPG_ERR_INTERNAL" "\0"
+  "GPG_ERR_EOF_GCRYPT" "\0"
+  "GPG_ERR_INV_OBJ" "\0"
+  "GPG_ERR_TOO_SHORT" "\0"
+  "GPG_ERR_TOO_LARGE" "\0"
+  "GPG_ERR_NO_OBJ" "\0"
+  "GPG_ERR_NOT_IMPLEMENTED" "\0"
+  "GPG_ERR_CONFLICT" "\0"
+  "GPG_ERR_INV_CIPHER_MODE" "\0"
+  "GPG_ERR_INV_FLAG" "\0"
+  "GPG_ERR_INV_HANDLE" "\0"
+  "GPG_ERR_TRUNCATED" "\0"
+  "GPG_ERR_INCOMPLETE_LINE" "\0"
+  "GPG_ERR_INV_RESPONSE" "\0"
+  "GPG_ERR_NO_AGENT" "\0"
+  "GPG_ERR_AGENT" "\0"
+  "GPG_ERR_INV_DATA" "\0"
+  "GPG_ERR_ASSUAN_SERVER_FAULT" "\0"
+  "GPG_ERR_ASSUAN" "\0"
+  "GPG_ERR_INV_SESSION_KEY" "\0"
+  "GPG_ERR_INV_SEXP" "\0"
+  "GPG_ERR_UNSUPPORTED_ALGORITHM" "\0"
+  "GPG_ERR_NO_PIN_ENTRY" "\0"
+  "GPG_ERR_PIN_ENTRY" "\0"
+  "GPG_ERR_BAD_PIN" "\0"
+  "GPG_ERR_INV_NAME" "\0"
+  "GPG_ERR_BAD_DATA" "\0"
+  "GPG_ERR_INV_PARAMETER" "\0"
+  "GPG_ERR_WRONG_CARD" "\0"
+  "GPG_ERR_NO_DIRMNGR" "\0"
+  "GPG_ERR_DIRMNGR" "\0"
+  "GPG_ERR_CERT_REVOKED" "\0"
+  "GPG_ERR_NO_CRL_KNOWN" "\0"
+  "GPG_ERR_CRL_TOO_OLD" "\0"
+  "GPG_ERR_LINE_TOO_LONG" "\0"
+  "GPG_ERR_NOT_TRUSTED" "\0"
+  "GPG_ERR_CANCELED" "\0"
+  "GPG_ERR_BAD_CA_CERT" "\0"
+  "GPG_ERR_CERT_EXPIRED" "\0"
+  "GPG_ERR_CERT_TOO_YOUNG" "\0"
+  "GPG_ERR_UNSUPPORTED_CERT" "\0"
+  "GPG_ERR_UNKNOWN_SEXP" "\0"
+  "GPG_ERR_UNSUPPORTED_PROTECTION" "\0"
+  "GPG_ERR_CORRUPTED_PROTECTION" "\0"
+  "GPG_ERR_AMBIGUOUS_NAME" "\0"
+  "GPG_ERR_CARD" "\0"
+  "GPG_ERR_CARD_RESET" "\0"
+  "GPG_ERR_CARD_REMOVED" "\0"
+  "GPG_ERR_INV_CARD" "\0"
+  "GPG_ERR_CARD_NOT_PRESENT" "\0"
+  "GPG_ERR_NO_PKCS15_APP" "\0"
+  "GPG_ERR_NOT_CONFIRMED" "\0"
+  "GPG_ERR_CONFIGURATION" "\0"
+  "GPG_ERR_NO_POLICY_MATCH" "\0"
+  "GPG_ERR_INV_INDEX" "\0"
+  "GPG_ERR_INV_ID" "\0"
+  "GPG_ERR_NO_SCDAEMON" "\0"
+  "GPG_ERR_SCDAEMON" "\0"
+  "GPG_ERR_UNSUPPORTED_PROTOCOL" "\0"
+  "GPG_ERR_BAD_PIN_METHOD" "\0"
+  "GPG_ERR_CARD_NOT_INITIALIZED" "\0"
+  "GPG_ERR_UNSUPPORTED_OPERATION" "\0"
+  "GPG_ERR_WRONG_KEY_USAGE" "\0"
+  "GPG_ERR_NOTHING_FOUND" "\0"
+  "GPG_ERR_WRONG_BLOB_TYPE" "\0"
+  "GPG_ERR_MISSING_VALUE" "\0"
+  "GPG_ERR_HARDWARE" "\0"
+  "GPG_ERR_PIN_BLOCKED" "\0"
+  "GPG_ERR_USE_CONDITIONS" "\0"
+  "GPG_ERR_PIN_NOT_SYNCED" "\0"
+  "GPG_ERR_INV_CRL" "\0"
+  "GPG_ERR_BAD_BER" "\0"
+  "GPG_ERR_INV_BER" "\0"
+  "GPG_ERR_ELEMENT_NOT_FOUND" "\0"
+  "GPG_ERR_IDENTIFIER_NOT_FOUND" "\0"
+  "GPG_ERR_INV_TAG" "\0"
+  "GPG_ERR_INV_LENGTH" "\0"
+  "GPG_ERR_INV_KEYINFO" "\0"
+  "GPG_ERR_UNEXPECTED_TAG" "\0"
+  "GPG_ERR_NOT_DER_ENCODED" "\0"
+  "GPG_ERR_NO_CMS_OBJ" "\0"
+  "GPG_ERR_INV_CMS_OBJ" "\0"
+  "GPG_ERR_UNKNOWN_CMS_OBJ" "\0"
+  "GPG_ERR_UNSUPPORTED_CMS_OBJ" "\0"
+  "GPG_ERR_UNSUPPORTED_ENCODING" "\0"
+  "GPG_ERR_UNSUPPORTED_CMS_VERSION" "\0"
+  "GPG_ERR_UNKNOWN_ALGORITHM" "\0"
+  "GPG_ERR_INV_ENGINE" "\0"
+  "GPG_ERR_PUBKEY_NOT_TRUSTED" "\0"
+  "GPG_ERR_DECRYPT_FAILED" "\0"
+  "GPG_ERR_KEY_EXPIRED" "\0"
+  "GPG_ERR_SIG_EXPIRED" "\0"
+  "GPG_ERR_ENCODING_PROBLEM" "\0"
+  "GPG_ERR_INV_STATE" "\0"
+  "GPG_ERR_DUP_VALUE" "\0"
+  "GPG_ERR_MISSING_ACTION" "\0"
+  "GPG_ERR_MODULE_NOT_FOUND" "\0"
+  "GPG_ERR_INV_OID_STRING" "\0"
+  "GPG_ERR_INV_TIME" "\0"
+  "GPG_ERR_INV_CRL_OBJ" "\0"
+  "GPG_ERR_UNSUPPORTED_CRL_VERSION" "\0"
+  "GPG_ERR_INV_CERT_OBJ" "\0"
+  "GPG_ERR_UNKNOWN_NAME" "\0"
+  "GPG_ERR_LOCALE_PROBLEM" "\0"
+  "GPG_ERR_NOT_LOCKED" "\0"
+  "GPG_ERR_PROTOCOL_VIOLATION" "\0"
+  "GPG_ERR_INV_MAC" "\0"
+  "GPG_ERR_INV_REQUEST" "\0"
+  "GPG_ERR_UNKNOWN_EXTN" "\0"
+  "GPG_ERR_UNKNOWN_CRIT_EXTN" "\0"
+  "GPG_ERR_LOCKED" "\0"
+  "GPG_ERR_UNKNOWN_OPTION" "\0"
+  "GPG_ERR_UNKNOWN_COMMAND" "\0"
+  "GPG_ERR_NOT_OPERATIONAL" "\0"
+  "GPG_ERR_NO_PASSPHRASE" "\0"
+  "GPG_ERR_NO_PIN" "\0"
+  "GPG_ERR_NOT_ENABLED" "\0"
+  "GPG_ERR_NO_ENGINE" "\0"
+  "GPG_ERR_MISSING_KEY" "\0"
+  "GPG_ERR_TOO_MANY" "\0"
+  "GPG_ERR_LIMIT_REACHED" "\0"
+  "GPG_ERR_NOT_INITIALIZED" "\0"
+  "GPG_ERR_MISSING_ISSUER_CERT" "\0"
+  "GPG_ERR_NO_KEYSERVER" "\0"
+  "GPG_ERR_INV_CURVE" "\0"
+  "GPG_ERR_UNKNOWN_CURVE" "\0"
+  "GPG_ERR_DUP_KEY" "\0"
+  "GPG_ERR_AMBIGUOUS" "\0"
+  "GPG_ERR_NO_CRYPT_CTX" "\0"
+  "GPG_ERR_WRONG_CRYPT_CTX" "\0"
+  "GPG_ERR_BAD_CRYPT_CTX" "\0"
+  "GPG_ERR_CRYPT_CTX_CONFLICT" "\0"
+  "GPG_ERR_BROKEN_PUBKEY" "\0"
+  "GPG_ERR_BROKEN_SECKEY" "\0"
+  "GPG_ERR_MAC_ALGO" "\0"
+  "GPG_ERR_FULLY_CANCELED" "\0"
+  "GPG_ERR_UNFINISHED" "\0"
+  "GPG_ERR_BUFFER_TOO_SHORT" "\0"
+  "GPG_ERR_SEXP_INV_LEN_SPEC" "\0"
+  "GPG_ERR_SEXP_STRING_TOO_LONG" "\0"
+  "GPG_ERR_SEXP_UNMATCHED_PAREN" "\0"
+  "GPG_ERR_SEXP_NOT_CANONICAL" "\0"
+  "GPG_ERR_SEXP_BAD_CHARACTER" "\0"
+  "GPG_ERR_SEXP_BAD_QUOTATION" "\0"
+  "GPG_ERR_SEXP_ZERO_PREFIX" "\0"
+  "GPG_ERR_SEXP_NESTED_DH" "\0"
+  "GPG_ERR_SEXP_UNMATCHED_DH" "\0"
+  "GPG_ERR_SEXP_UNEXPECTED_PUNC" "\0"
+  "GPG_ERR_SEXP_BAD_HEX_CHAR" "\0"
+  "GPG_ERR_SEXP_ODD_HEX_NUMBERS" "\0"
+  "GPG_ERR_SEXP_BAD_OCT_CHAR" "\0"
+  "GPG_ERR_SUBKEYS_EXP_OR_REV" "\0"
+  "GPG_ERR_DB_CORRUPTED" "\0"
+  "GPG_ERR_SERVER_FAILED" "\0"
+  "GPG_ERR_NO_NAME" "\0"
+  "GPG_ERR_NO_KEY" "\0"
+  "GPG_ERR_LEGACY_KEY" "\0"
+  "GPG_ERR_REQUEST_TOO_SHORT" "\0"
+  "GPG_ERR_REQUEST_TOO_LONG" "\0"
+  "GPG_ERR_OBJ_TERM_STATE" "\0"
+  "GPG_ERR_NO_CERT_CHAIN" "\0"
+  "GPG_ERR_CERT_TOO_LARGE" "\0"
+  "GPG_ERR_INV_RECORD" "\0"
+  "GPG_ERR_BAD_MAC" "\0"
+  "GPG_ERR_UNEXPECTED_MSG" "\0"
+  "GPG_ERR_COMPR_FAILED" "\0"
+  "GPG_ERR_WOULD_WRAP" "\0"
+  "GPG_ERR_FATAL_ALERT" "\0"
+  "GPG_ERR_NO_CIPHER" "\0"
+  "GPG_ERR_MISSING_CLIENT_CERT" "\0"
+  "GPG_ERR_CLOSE_NOTIFY" "\0"
+  "GPG_ERR_TICKET_EXPIRED" "\0"
+  "GPG_ERR_BAD_TICKET" "\0"
+  "GPG_ERR_UNKNOWN_IDENTITY" "\0"
+  "GPG_ERR_BAD_HS_CERT" "\0"
+  "GPG_ERR_BAD_HS_CERT_REQ" "\0"
+  "GPG_ERR_BAD_HS_CERT_VER" "\0"
+  "GPG_ERR_BAD_HS_CHANGE_CIPHER" "\0"
+  "GPG_ERR_BAD_HS_CLIENT_HELLO" "\0"
+  "GPG_ERR_BAD_HS_SERVER_HELLO" "\0"
+  "GPG_ERR_BAD_HS_SERVER_HELLO_DONE" "\0"
+  "GPG_ERR_BAD_HS_FINISHED" "\0"
+  "GPG_ERR_BAD_HS_SERVER_KEX" "\0"
+  "GPG_ERR_BAD_HS_CLIENT_KEX" "\0"
+  "GPG_ERR_BOGUS_STRING" "\0"
+  "GPG_ERR_FORBIDDEN" "\0"
+  "GPG_ERR_KEY_DISABLED" "\0"
+  "GPG_ERR_KEY_ON_CARD" "\0"
+  "GPG_ERR_INV_LOCK_OBJ" "\0"
+  "GPG_ERR_TRUE" "\0"
+  "GPG_ERR_FALSE" "\0"
+  "GPG_ERR_ASS_GENERAL" "\0"
+  "GPG_ERR_ASS_ACCEPT_FAILED" "\0"
+  "GPG_ERR_ASS_CONNECT_FAILED" "\0"
+  "GPG_ERR_ASS_INV_RESPONSE" "\0"
+  "GPG_ERR_ASS_INV_VALUE" "\0"
+  "GPG_ERR_ASS_INCOMPLETE_LINE" "\0"
+  "GPG_ERR_ASS_LINE_TOO_LONG" "\0"
+  "GPG_ERR_ASS_NESTED_COMMANDS" "\0"
+  "GPG_ERR_ASS_NO_DATA_CB" "\0"
+  "GPG_ERR_ASS_NO_INQUIRE_CB" "\0"
+  "GPG_ERR_ASS_NOT_A_SERVER" "\0"
+  "GPG_ERR_ASS_NOT_A_CLIENT" "\0"
+  "GPG_ERR_ASS_SERVER_START" "\0"
+  "GPG_ERR_ASS_READ_ERROR" "\0"
+  "GPG_ERR_ASS_WRITE_ERROR" "\0"
+  "GPG_ERR_ASS_TOO_MUCH_DATA" "\0"
+  "GPG_ERR_ASS_UNEXPECTED_CMD" "\0"
+  "GPG_ERR_ASS_UNKNOWN_CMD" "\0"
+  "GPG_ERR_ASS_SYNTAX" "\0"
+  "GPG_ERR_ASS_CANCELED" "\0"
+  "GPG_ERR_ASS_NO_INPUT" "\0"
+  "GPG_ERR_ASS_NO_OUTPUT" "\0"
+  "GPG_ERR_ASS_PARAMETER" "\0"
+  "GPG_ERR_ASS_UNKNOWN_INQUIRE" "\0"
+  "GPG_ERR_ENGINE_TOO_OLD" "\0"
+  "GPG_ERR_WINDOW_TOO_SMALL" "\0"
+  "GPG_ERR_WINDOW_TOO_LARGE" "\0"
+  "GPG_ERR_MISSING_ENVVAR" "\0"
+  "GPG_ERR_USER_ID_EXISTS" "\0"
+  "GPG_ERR_NAME_EXISTS" "\0"
+  "GPG_ERR_DUP_NAME" "\0"
+  "GPG_ERR_TOO_YOUNG" "\0"
+  "GPG_ERR_TOO_OLD" "\0"
+  "GPG_ERR_UNKNOWN_FLAG" "\0"
+  "GPG_ERR_INV_ORDER" "\0"
+  "GPG_ERR_ALREADY_FETCHED" "\0"
+  "GPG_ERR_TRY_LATER" "\0"
+  "GPG_ERR_WRONG_NAME" "\0"
+  "GPG_ERR_NO_AUTH" "\0"
+  "GPG_ERR_BAD_AUTH" "\0"
+  "GPG_ERR_SYSTEM_BUG" "\0"
+  "GPG_ERR_DNS_UNKNOWN" "\0"
+  "GPG_ERR_DNS_SECTION" "\0"
+  "GPG_ERR_DNS_ADDRESS" "\0"
+  "GPG_ERR_DNS_NO_QUERY" "\0"
+  "GPG_ERR_DNS_NO_ANSWER" "\0"
+  "GPG_ERR_DNS_CLOSED" "\0"
+  "GPG_ERR_DNS_VERIFY" "\0"
+  "GPG_ERR_DNS_TIMEOUT" "\0"
+  "GPG_ERR_LDAP_GENERAL" "\0"
+  "GPG_ERR_LDAP_ATTR_GENERAL" "\0"
+  "GPG_ERR_LDAP_NAME_GENERAL" "\0"
+  "GPG_ERR_LDAP_SECURITY_GENERAL" "\0"
+  "GPG_ERR_LDAP_SERVICE_GENERAL" "\0"
+  "GPG_ERR_LDAP_UPDATE_GENERAL" "\0"
+  "GPG_ERR_LDAP_E_GENERAL" "\0"
+  "GPG_ERR_LDAP_X_GENERAL" "\0"
+  "GPG_ERR_LDAP_OTHER_GENERAL" "\0"
+  "GPG_ERR_LDAP_X_CONNECTING" "\0"
+  "GPG_ERR_LDAP_REFERRAL_LIMIT" "\0"
+  "GPG_ERR_LDAP_CLIENT_LOOP" "\0"
+  "GPG_ERR_LDAP_NO_RESULTS" "\0"
+  "GPG_ERR_LDAP_CONTROL_NOT_FOUND" "\0"
+  "GPG_ERR_LDAP_NOT_SUPPORTED" "\0"
+  "GPG_ERR_LDAP_CONNECT" "\0"
+  "GPG_ERR_LDAP_NO_MEMORY" "\0"
+  "GPG_ERR_LDAP_PARAM" "\0"
+  "GPG_ERR_LDAP_USER_CANCELLED" "\0"
+  "GPG_ERR_LDAP_FILTER" "\0"
+  "GPG_ERR_LDAP_AUTH_UNKNOWN" "\0"
+  "GPG_ERR_LDAP_TIMEOUT" "\0"
+  "GPG_ERR_LDAP_DECODING" "\0"
+  "GPG_ERR_LDAP_ENCODING" "\0"
+  "GPG_ERR_LDAP_LOCAL" "\0"
+  "GPG_ERR_LDAP_SERVER_DOWN" "\0"
+  "GPG_ERR_LDAP_SUCCESS" "\0"
+  "GPG_ERR_LDAP_OPERATIONS" "\0"
+  "GPG_ERR_LDAP_PROTOCOL" "\0"
+  "GPG_ERR_LDAP_TIMELIMIT" "\0"
+  "GPG_ERR_LDAP_SIZELIMIT" "\0"
+  "GPG_ERR_LDAP_COMPARE_FALSE" "\0"
+  "GPG_ERR_LDAP_COMPARE_TRUE" "\0"
+  "GPG_ERR_LDAP_UNSUPPORTED_AUTH" "\0"
+  "GPG_ERR_LDAP_STRONG_AUTH_RQRD" "\0"
+  "GPG_ERR_LDAP_PARTIAL_RESULTS" "\0"
+  "GPG_ERR_LDAP_REFERRAL" "\0"
+  "GPG_ERR_LDAP_ADMINLIMIT" "\0"
+  "GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN" "\0"
+  "GPG_ERR_LDAP_CONFIDENT_RQRD" "\0"
+  "GPG_ERR_LDAP_SASL_BIND_INPROG" "\0"
+  "GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE" "\0"
+  "GPG_ERR_LDAP_UNDEFINED_TYPE" "\0"
+  "GPG_ERR_LDAP_BAD_MATCHING" "\0"
+  "GPG_ERR_LDAP_CONST_VIOLATION" "\0"
+  "GPG_ERR_LDAP_TYPE_VALUE_EXISTS" "\0"
+  "GPG_ERR_LDAP_INV_SYNTAX" "\0"
+  "GPG_ERR_LDAP_NO_SUCH_OBJ" "\0"
+  "GPG_ERR_LDAP_ALIAS_PROBLEM" "\0"
+  "GPG_ERR_LDAP_INV_DN_SYNTAX" "\0"
+  "GPG_ERR_LDAP_IS_LEAF" "\0"
+  "GPG_ERR_LDAP_ALIAS_DEREF" "\0"
+  "GPG_ERR_LDAP_X_PROXY_AUTH_FAIL" "\0"
+  "GPG_ERR_LDAP_BAD_AUTH" "\0"
+  "GPG_ERR_LDAP_INV_CREDENTIALS" "\0"
+  "GPG_ERR_LDAP_INSUFFICIENT_ACC" "\0"
+  "GPG_ERR_LDAP_BUSY" "\0"
+  "GPG_ERR_LDAP_UNAVAILABLE" "\0"
+  "GPG_ERR_LDAP_UNWILL_TO_PERFORM" "\0"
+  "GPG_ERR_LDAP_LOOP_DETECT" "\0"
+  "GPG_ERR_LDAP_NAMING_VIOLATION" "\0"
+  "GPG_ERR_LDAP_OBJ_CLS_VIOLATION" "\0"
+  "GPG_ERR_LDAP_NOT_ALLOW_NONLEAF" "\0"
+  "GPG_ERR_LDAP_NOT_ALLOW_ON_RDN" "\0"
+  "GPG_ERR_LDAP_ALREADY_EXISTS" "\0"
+  "GPG_ERR_LDAP_NO_OBJ_CLASS_MODS" "\0"
+  "GPG_ERR_LDAP_RESULTS_TOO_LARGE" "\0"
+  "GPG_ERR_LDAP_AFFECTS_MULT_DSAS" "\0"
+  "GPG_ERR_LDAP_VLV" "\0"
+  "GPG_ERR_LDAP_OTHER" "\0"
+  "GPG_ERR_LDAP_CUP_RESOURCE_LIMIT" "\0"
+  "GPG_ERR_LDAP_CUP_SEC_VIOLATION" "\0"
+  "GPG_ERR_LDAP_CUP_INV_DATA" "\0"
+  "GPG_ERR_LDAP_CUP_UNSUP_SCHEME" "\0"
+  "GPG_ERR_LDAP_CUP_RELOAD" "\0"
+  "GPG_ERR_LDAP_CANCELLED" "\0"
+  "GPG_ERR_LDAP_NO_SUCH_OPERATION" "\0"
+  "GPG_ERR_LDAP_TOO_LATE" "\0"
+  "GPG_ERR_LDAP_CANNOT_CANCEL" "\0"
+  "GPG_ERR_LDAP_ASSERTION_FAILED" "\0"
+  "GPG_ERR_LDAP_PROX_AUTH_DENIED" "\0"
+  "GPG_ERR_USER_1" "\0"
+  "GPG_ERR_USER_2" "\0"
+  "GPG_ERR_USER_3" "\0"
+  "GPG_ERR_USER_4" "\0"
+  "GPG_ERR_USER_5" "\0"
+  "GPG_ERR_USER_6" "\0"
+  "GPG_ERR_USER_7" "\0"
+  "GPG_ERR_USER_8" "\0"
+  "GPG_ERR_USER_9" "\0"
+  "GPG_ERR_USER_10" "\0"
+  "GPG_ERR_USER_11" "\0"
+  "GPG_ERR_USER_12" "\0"
+  "GPG_ERR_USER_13" "\0"
+  "GPG_ERR_USER_14" "\0"
+  "GPG_ERR_USER_15" "\0"
+  "GPG_ERR_USER_16" "\0"
+  "GPG_ERR_MISSING_ERRNO" "\0"
+  "GPG_ERR_UNKNOWN_ERRNO" "\0"
+  "GPG_ERR_EOF" "\0"
+  "GPG_ERR_CODE_DIM";
+
+static const int msgidx[] =
+  {
+    0,
+    17,
+    33,
+    56,
+    80,
+    100,
+    120,
+    139,
+    158,
+    180,
+    198,
+    215,
+    238,
+    258,
+    279,
+    298,
+    316,
+    335,
+    353,
+    374,
+    390,
+    409,
+    426,
+    453,
+    482,
+    510,
+    527,
+    544,
+    562,
+    586,
+    601,
+    617,
+    640,
+    658,
+    681,
+    701,
+    717,
+    734,
+    754,
+    773,
+    795,
+    813,
+    839,
+    862,
+    879,
+    898,
+    914,
+    930,
+    946,
+    962,
+    983,
+    1007,
+    1029,
+    1051,
+    1075,
+    1099,
+    1117,
+    1140,
+    1161,
+    1177,
+    1189,
+    1211,
+    1226,
+    1242,
+    1259,
+    1278,
+    1294,
+    1312,
+    1330,
+    1345,
+    1369,
+    1386,
+    1410,
+    1427,
+    1446,
+    1464,
+    1488,
+    1509,
+    1526,
+    1540,
+    1557,
+    1585,
+    1600,
+    1624,
+    1641,
+    1671,
+    1692,
+    1710,
+    1726,
+    1743,
+    1760,
+    1782,
+    1801,
+    1820,
+    1836,
+    1857,
+    1878,
+    1898,
+    1920,
+    1940,
+    1957,
+    1977,
+    1998,
+    2021,
+    2046,
+    2067,
+    2098,
+    2127,
+    2150,
+    2163,
+    2182,
+    2203,
+    2220,
+    2245,
+    2267,
+    2289,
+    2311,
+    2335,
+    2353,
+    2368,
+    2388,
+    2405,
+    2434,
+    2457,
+    2486,
+    2516,
+    2540,
+    2562,
+    2586,
+    2608,
+    2625,
+    2645,
+    2668,
+    2691,
+    2707,
+    2723,
+    2739,
+    2765,
+    2794,
+    2810,
+    2829,
+    2849,
+    2872,
+    2896,
+    2915,
+    2935,
+    2959,
+    2987,
+    3016,
+    3048,
+    3074,
+    3093,
+    3120,
+    3143,
+    3163,
+    3183,
+    3208,
+    3226,
+    3244,
+    3267,
+    3292,
+    3315,
+    3332,
+    3352,
+    3384,
+    3405,
+    3426,
+    3449,
+    3468,
+    3495,
+    3511,
+    3531,
+    3552,
+    3578,
+    3593,
+    3616,
+    3640,
+    3664,
+    3686,
+    3701,
+    3721,
+    3739,
+    3759,
+    3776,
+    3798,
+    3822,
+    3850,
+    3871,
+    3889,
+    3911,
+    3927,
+    3945,
+    3966,
+    3990,
+    4012,
+    4039,
+    4061,
+    4083,
+    4100,
+    4123,
+    4142,
+    4167,
+    4193,
+    4222,
+    4251,
+    4278,
+    4305,
+    4332,
+    4357,
+    4380,
+    4406,
+    4435,
+    4461,
+    4490,
+    4516,
+    4543,
+    4564,
+    4586,
+    4602,
+    4617,
+    4636,
+    4662,
+    4687,
+    4710,
+    4732,
+    4755,
+    4774,
+    4790,
+    4813,
+    4834,
+    4853,
+    4873,
+    4891,
+    4919,
+    4940,
+    4963,
+    4982,
+    5007,
+    5027,
+    5051,
+    5075,
+    5104,
+    5132,
+    5160,
+    5193,
+    5217,
+    5243,
+    5269,
+    5290,
+    5308,
+    5329,
+    5349,
+    5370,
+    5383,
+    5397,
+    5417,
+    5443,
+    5470,
+    5495,
+    5517,
+    5545,
+    5571,
+    5599,
+    5622,
+    5648,
+    5673,
+    5698,
+    5723,
+    5746,
+    5770,
+    5796,
+    5823,
+    5847,
+    5866,
+    5887,
+    5908,
+    5930,
+    5952,
+    5980,
+    6003,
+    6028,
+    6053,
+    6076,
+    6099,
+    6119,
+    6136,
+    6154,
+    6170,
+    6191,
+    6209,
+    6233,
+    6251,
+    6270,
+    6286,
+    6303,
+    6322,
+    6342,
+    6362,
+    6382,
+    6403,
+    6425,
+    6444,
+    6463,
+    6483,
+    6504,
+    6530,
+    6556,
+    6586,
+    6615,
+    6643,
+    6666,
+    6689,
+    6716,
+    6742,
+    6770,
+    6795,
+    6819,
+    6850,
+    6877,
+    6898,
+    6921,
+    6940,
+    6968,
+    6988,
+    7014,
+    7035,
+    7057,
+    7079,
+    7098,
+    7123,
+    7144,
+    7168,
+    7190,
+    7213,
+    7236,
+    7263,
+    7289,
+    7319,
+    7349,
+    7378,
+    7400,
+    7424,
+    7455,
+    7483,
+    7513,
+    7544,
+    7572,
+    7598,
+    7627,
+    7658,
+    7682,
+    7707,
+    7734,
+    7761,
+    7782,
+    7807,
+    7838,
+    7860,
+    7889,
+    7919,
+    7937,
+    7962,
+    7993,
+    8018,
+    8048,
+    8079,
+    8110,
+    8140,
+    8168,
+    8199,
+    8230,
+    8261,
+    8278,
+    8297,
+    8329,
+    8360,
+    8386,
+    8416,
+    8440,
+    8463,
+    8494,
+    8516,
+    8543,
+    8573,
+    8603,
+    8618,
+    8633,
+    8648,
+    8663,
+    8678,
+    8693,
+    8708,
+    8723,
+    8738,
+    8754,
+    8770,
+    8786,
+    8802,
+    8818,
+    8834,
+    8850,
+    8872,
+    8894,
+    8906
+  };
+
+static GPG_ERR_INLINE int
+msgidxof (int code)
+{
+  return (0 ? 0
+  : ((code >= 0) && (code <= 213)) ? (code - 0)
+  : ((code >= 217) && (code <= 271)) ? (code - 3)
+  : ((code >= 273) && (code <= 281)) ? (code - 4)
+  : ((code >= 300) && (code <= 315)) ? (code - 22)
+  : ((code >= 666) && (code <= 666)) ? (code - 372)
+  : ((code >= 711) && (code <= 718)) ? (code - 416)
+  : ((code >= 721) && (code <= 729)) ? (code - 418)
+  : ((code >= 750) && (code <= 752)) ? (code - 438)
+  : ((code >= 754) && (code <= 782)) ? (code - 439)
+  : ((code >= 784) && (code <= 789)) ? (code - 440)
+  : ((code >= 800) && (code <= 804)) ? (code - 450)
+  : ((code >= 815) && (code <= 822)) ? (code - 460)
+  : ((code >= 832) && (code <= 839)) ? (code - 469)
+  : ((code >= 844) && (code <= 844)) ? (code - 473)
+  : ((code >= 848) && (code <= 848)) ? (code - 476)
+  : ((code >= 881) && (code <= 891)) ? (code - 508)
+  : ((code >= 1024) && (code <= 1039)) ? (code - 640)
+  : ((code >= 16381) && (code <= 16383)) ? (code - 15981)
+  : 16384 - 15981);
+}
diff --git a/src/err-sources-sym.h b/src/err-sources-sym.h
new file mode 100644
index 0000000..98388e9
--- /dev/null
+++ b/src/err-sources-sym.h
@@ -0,0 +1,87 @@
+/* Output of mkstrtable.awk.  DO NOT EDIT.  */
+
+/* err-sources.h - List of error sources and their description.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+/* The purpose of this complex string table is to produce
+   optimal code with a minimum of relocations.  */
+
+static const char msgstr[] = 
+  "GPG_ERR_SOURCE_UNKNOWN" "\0"
+  "GPG_ERR_SOURCE_GCRYPT" "\0"
+  "GPG_ERR_SOURCE_GPG" "\0"
+  "GPG_ERR_SOURCE_GPGSM" "\0"
+  "GPG_ERR_SOURCE_GPGAGENT" "\0"
+  "GPG_ERR_SOURCE_PINENTRY" "\0"
+  "GPG_ERR_SOURCE_SCD" "\0"
+  "GPG_ERR_SOURCE_GPGME" "\0"
+  "GPG_ERR_SOURCE_KEYBOX" "\0"
+  "GPG_ERR_SOURCE_KSBA" "\0"
+  "GPG_ERR_SOURCE_DIRMNGR" "\0"
+  "GPG_ERR_SOURCE_GSTI" "\0"
+  "GPG_ERR_SOURCE_GPA" "\0"
+  "GPG_ERR_SOURCE_KLEO" "\0"
+  "GPG_ERR_SOURCE_G13" "\0"
+  "GPG_ERR_SOURCE_ASSUAN" "\0"
+  "GPG_ERR_SOURCE_TLS" "\0"
+  "GPG_ERR_SOURCE_ANY" "\0"
+  "GPG_ERR_SOURCE_USER_1" "\0"
+  "GPG_ERR_SOURCE_USER_2" "\0"
+  "GPG_ERR_SOURCE_USER_3" "\0"
+  "GPG_ERR_SOURCE_USER_4" "\0"
+  "GPG_ERR_SOURCE_DIM";
+
+static const int msgidx[] =
+  {
+    0,
+    23,
+    45,
+    64,
+    85,
+    109,
+    133,
+    152,
+    173,
+    195,
+    215,
+    238,
+    258,
+    277,
+    297,
+    316,
+    338,
+    357,
+    376,
+    398,
+    420,
+    442,
+    464
+  };
+
+static GPG_ERR_INLINE int
+msgidxof (int code)
+{
+  return (0 ? 0
+  : ((code >= 0) && (code <= 15)) ? (code - 0)
+  : ((code >= 17) && (code <= 17)) ? (code - 1)
+  : ((code >= 31) && (code <= 35)) ? (code - 14)
+  : 36 - 14);
+}
diff --git a/src/errnos-sym.h b/src/errnos-sym.h
new file mode 100644
index 0000000..42804ae
--- /dev/null
+++ b/src/errnos-sym.h
@@ -0,0 +1,323 @@
+/* Output of mkstrtable.awk.  DO NOT EDIT.  */
+
+/* errnos.in - List of system error values.
+   Copyright (C) 2003, 2004 g10 Code GmbH
+
+   This file is part of libgpg-error.
+
+   libgpg-error is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License
+   as published by the Free Software Foundation; either version 2.1 of
+   the License, or (at your option) any later version.
+
+   libgpg-error is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with libgpg-error; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+
+
+/* The purpose of this complex string table is to produce
+   optimal code with a minimum of relocations.  */
+
+static const char errnos_msgstr[] = 
+  "GPG_ERR_E2BIG" "\0"
+  "GPG_ERR_EACCES" "\0"
+  "GPG_ERR_EADDRINUSE" "\0"
+  "GPG_ERR_EADDRNOTAVAIL" "\0"
+  "GPG_ERR_EADV" "\0"
+  "GPG_ERR_EAFNOSUPPORT" "\0"
+  "GPG_ERR_EAGAIN" "\0"
+  "GPG_ERR_EALREADY" "\0"
+  "GPG_ERR_EAUTH" "\0"
+  "GPG_ERR_EBACKGROUND" "\0"
+  "GPG_ERR_EBADE" "\0"
+  "GPG_ERR_EBADF" "\0"
+  "GPG_ERR_EBADFD" "\0"
+  "GPG_ERR_EBADMSG" "\0"
+  "GPG_ERR_EBADR" "\0"
+  "GPG_ERR_EBADRPC" "\0"
+  "GPG_ERR_EBADRQC" "\0"
+  "GPG_ERR_EBADSLT" "\0"
+  "GPG_ERR_EBFONT" "\0"
+  "GPG_ERR_EBUSY" "\0"
+  "GPG_ERR_ECANCELED" "\0"
+  "GPG_ERR_ECHILD" "\0"
+  "GPG_ERR_ECHRNG" "\0"
+  "GPG_ERR_ECOMM" "\0"
+  "GPG_ERR_ECONNABORTED" "\0"
+  "GPG_ERR_ECONNREFUSED" "\0"
+  "GPG_ERR_ECONNRESET" "\0"
+  "GPG_ERR_ED" "\0"
+  "GPG_ERR_EDEADLK" "\0"
+  "GPG_ERR_EDEADLOCK" "\0"
+  "GPG_ERR_EDESTADDRREQ" "\0"
+  "GPG_ERR_EDIED" "\0"
+  "GPG_ERR_EDOM" "\0"
+  "GPG_ERR_EDOTDOT" "\0"
+  "GPG_ERR_EDQUOT" "\0"
+  "GPG_ERR_EEXIST" "\0"
+  "GPG_ERR_EFAULT" "\0"
+  "GPG_ERR_EFBIG" "\0"
+  "GPG_ERR_EFTYPE" "\0"
+  "GPG_ERR_EGRATUITOUS" "\0"
+  "GPG_ERR_EGREGIOUS" "\0"
+  "GPG_ERR_EHOSTDOWN" "\0"
+  "GPG_ERR_EHOSTUNREACH" "\0"
+  "GPG_ERR_EIDRM" "\0"
+  "GPG_ERR_EIEIO" "\0"
+  "GPG_ERR_EILSEQ" "\0"
+  "GPG_ERR_EINPROGRESS" "\0"
+  "GPG_ERR_EINTR" "\0"
+  "GPG_ERR_EINVAL" "\0"
+  "GPG_ERR_EIO" "\0"
+  "GPG_ERR_EISCONN" "\0"
+  "GPG_ERR_EISDIR" "\0"
+  "GPG_ERR_EISNAM" "\0"
+  "GPG_ERR_EL2HLT" "\0"
+  "GPG_ERR_EL2NSYNC" "\0"
+  "GPG_ERR_EL3HLT" "\0"
+  "GPG_ERR_EL3RST" "\0"
+  "GPG_ERR_ELIBACC" "\0"
+  "GPG_ERR_ELIBBAD" "\0"
+  "GPG_ERR_ELIBEXEC" "\0"
+  "GPG_ERR_ELIBMAX" "\0"
+  "GPG_ERR_ELIBSCN" "\0"
+  "GPG_ERR_ELNRNG" "\0"
+  "GPG_ERR_ELOOP" "\0"
+  "GPG_ERR_EMEDIUMTYPE" "\0"
+  "GPG_ERR_EMFILE" "\0"
+  "GPG_ERR_EMLINK" "\0"
+  "GPG_ERR_EMSGSIZE" "\0"
+  "GPG_ERR_EMULTIHOP" "\0"
+  "GPG_ERR_ENAMETOOLONG" "\0"
+  "GPG_ERR_ENAVAIL" "\0"
+  "GPG_ERR_ENEEDAUTH" "\0"
+  "GPG_ERR_ENETDOWN" "\0"
+  "GPG_ERR_ENETRESET" "\0"
+  "GPG_ERR_ENETUNREACH" "\0"
+  "GPG_ERR_ENFILE" "\0"
+  "GPG_ERR_ENOANO" "\0"
+  "GPG_ERR_ENOBUFS" "\0"
+  "GPG_ERR_ENOCSI" "\0"
+  "GPG_ERR_ENODATA" "\0"
+  "GPG_ERR_ENODEV" "\0"
+  "GPG_ERR_ENOENT" "\0"
+  "GPG_ERR_ENOEXEC" "\0"
+  "GPG_ERR_ENOLCK" "\0"
+  "GPG_ERR_ENOLINK" "\0"
+  "GPG_ERR_ENOMEDIUM" "\0"
+  "GPG_ERR_ENOMEM" "\0"
+  "GPG_ERR_ENOMSG" "\0"
+  "GPG_ERR_ENONET" "\0"
+  "GPG_ERR_ENOPKG" "\0"
+  "GPG_ERR_ENOPROTOOPT" "\0"
+  "GPG_ERR_ENOSPC" "\0"
+  "GPG_ERR_ENOSR" "\0"
+  "GPG_ERR_ENOSTR" "\0"
+  "GPG_ERR_ENOSYS" "\0"
+  "GPG_ERR_ENOTBLK" "\0"
+  "GPG_ERR_ENOTCONN" "\0"
+  "GPG_ERR_ENOTDIR" "\0"
+  "GPG_ERR_ENOTEMPTY" "\0"
+  "GPG_ERR_ENOTNAM" "\0"
+  "GPG_ERR_ENOTSOCK" "\0"
+  "GPG_ERR_ENOTSUP" "\0"
+  "GPG_ERR_ENOTTY" "\0"
+  "GPG_ERR_ENOTUNIQ" "\0"
+  "GPG_ERR_ENXIO" "\0"
+  "GPG_ERR_EOPNOTSUPP" "\0"
+  "GPG_ERR_EOVERFLOW" "\0"
+  "GPG_ERR_EPERM" "\0"
+  "GPG_ERR_EPFNOSUPPORT" "\0"
+  "GPG_ERR_EPIPE" "\0"
+  "GPG_ERR_EPROCLIM" "\0"
+  "GPG_ERR_EPROCUNAVAIL" "\0"
+  "GPG_ERR_EPROGMISMATCH" "\0"
+  "GPG_ERR_EPROGUNAVAIL" "\0"
+  "GPG_ERR_EPROTO" "\0"
+  "GPG_ERR_EPROTONOSUPPORT" "\0"
+  "GPG_ERR_EPROTOTYPE" "\0"
+  "GPG_ERR_ERANGE" "\0"
+  "GPG_ERR_EREMCHG" "\0"
+  "GPG_ERR_EREMOTE" "\0"
+  "GPG_ERR_EREMOTEIO" "\0"
+  "GPG_ERR_ERESTART" "\0"
+  "GPG_ERR_EROFS" "\0"
+  "GPG_ERR_ERPCMISMATCH" "\0"
+  "GPG_ERR_ESHUTDOWN" "\0"
+  "GPG_ERR_ESOCKTNOSUPPORT" "\0"
+  "GPG_ERR_ESPIPE" "\0"
+  "GPG_ERR_ESRCH" "\0"
+  "GPG_ERR_ESRMNT" "\0"
+  "GPG_ERR_ESTALE" "\0"
+  "GPG_ERR_ESTRPIPE" "\0"
+  "GPG_ERR_ETIME" "\0"
+  "GPG_ERR_ETIMEDOUT" "\0"
+  "GPG_ERR_ETOOMANYREFS" "\0"
+  "GPG_ERR_ETXTBSY" "\0"
+  "GPG_ERR_EUCLEAN" "\0"
+  "GPG_ERR_EUNATCH" "\0"
+  "GPG_ERR_EUSERS" "\0"
+  "GPG_ERR_EWOULDBLOCK" "\0"
+  "GPG_ERR_EXDEV" "\0"
+  "GPG_ERR_EXFULL";
+
+static const int errnos_msgidx[] =
+  {
+    0,
+    14,
+    29,
+    48,
+    70,
+    83,
+    104,
+    119,
+    136,
+    150,
+    170,
+    184,
+    198,
+    213,
+    229,
+    243,
+    259,
+    275,
+    291,
+    306,
+    320,
+    338,
+    353,
+    368,
+    382,
+    403,
+    424,
+    443,
+    454,
+    470,
+    488,
+    509,
+    523,
+    536,
+    552,
+    567,
+    582,
+    597,
+    611,
+    626,
+    646,
+    664,
+    682,
+    703,
+    717,
+    731,
+    746,
+    766,
+    780,
+    795,
+    807,
+    823,
+    838,
+    853,
+    868,
+    885,
+    900,
+    915,
+    931,
+    947,
+    964,
+    980,
+    996,
+    1011,
+    1025,
+    1045,
+    1060,
+    1075,
+    1092,
+    1110,
+    1131,
+    1147,
+    1165,
+    1182,
+    1200,
+    1220,
+    1235,
+    1250,
+    1266,
+    1281,
+    1297,
+    1312,
+    1327,
+    1343,
+    1358,
+    1374,
+    1392,
+    1407,
+    1422,
+    1437,
+    1452,
+    1472,
+    1487,
+    1501,
+    1516,
+    1531,
+    1547,
+    1564,
+    1580,
+    1598,
+    1614,
+    1631,
+    1647,
+    1662,
+    1679,
+    1693,
+    1712,
+    1730,
+    1744,
+    1765,
+    1779,
+    1796,
+    1817,
+    1839,
+    1860,
+    1875,
+    1899,
+    1918,
+    1933,
+    1949,
+    1965,
+    1983,
+    2000,
+    2014,
+    2035,
+    2053,
+    2077,
+    2092,
+    2106,
+    2121,
+    2136,
+    2153,
+    2167,
+    2185,
+    2206,
+    2222,
+    2238,
+    2254,
+    2269,
+    2289,
+    2303,
+    
+  };
+
+static GPG_ERR_INLINE int
+errnos_msgidxof (int code)
+{
+  return (0 ? 0
+  : ((code >= 0) && (code <= 140)) ? (code - 0)
+  : -1);
+}
diff --git a/src/estream-printf.c b/src/estream-printf.c
index bce6147..a123f10 100644
--- a/src/estream-printf.c
+++ b/src/estream-printf.c
@@ -85,7 +85,6 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
 #include <stdarg.h>
 #include <errno.h>
 #include <stddef.h>
@@ -820,7 +819,7 @@ read_values (valueitem_t valuetable, size_t valuetable_len, va_list vaargs)
    number of bytes actually written.  */
 static int
 pad_out (estream_printf_out_t outfnc, void *outfncarg,
-         int padchar, int count, size_t *nbytes)
+         int padchar, size_t count, size_t *nbytes)
 {
   char buf[32];
   size_t n;
diff --git a/src/estream.c b/src/estream.c
index 8b7ccc5..dc97c00 100644
--- a/src/estream.c
+++ b/src/estream.c
@@ -74,12 +74,10 @@
 # include <sys/time.h>
 #endif
 #include <sys/types.h>
-#include <sys/file.h>
 #include <sys/stat.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
-#include <unistd.h>
 #include <stdarg.h>
 #include <fcntl.h>
 #include <errno.h>
@@ -89,6 +87,7 @@
 #  include <winsock2.h>
 # endif
 # include <windows.h>
+# include <io.h>
 #endif
 
 /* Enable tracing.  The value is the module name to be printed.  */
@@ -111,6 +110,15 @@
 
 
 #ifdef HAVE_W32_SYSTEM
+# ifndef S_IRUSR
+#  define S_IRUSR 0x400
+# endif
+# ifndef S_IWUSR
+#  define S_IWUSR 0x200
+# endif
+# ifndef S_IXUSR
+#  define S_IXUSR 0x100
+# endif
 # ifndef  S_IRGRP
 #  define S_IRGRP S_IRUSR
 # endif
@@ -901,7 +909,7 @@ func_fd_create (void **cookie, int fd, unsigned int modeflags, int no_close)
 #ifdef HAVE_DOSISH_SYSTEM
       /* Make sure it is in binary mode if requested.  */
       if ( (modeflags & O_BINARY) )
-        setmode (fd, O_BINARY);
+        _setmode (fd, O_BINARY);
 #endif
       fd_cookie->fd = fd;
       fd_cookie->no_close = no_close;
@@ -939,7 +947,7 @@ func_fd_read (void *cookie, void *buffer, size_t size)
       _gpgrt_pre_syscall ();
       do
         {
-          bytes_read = read (file_cookie->fd, buffer, size);
+          bytes_read = _read (file_cookie->fd, buffer, size);
         }
       while (bytes_read == -1 && errno == EINTR);
       _gpgrt_post_syscall ();
@@ -971,7 +979,7 @@ func_fd_write (void *cookie, const void *buffer, size_t size)
       _gpgrt_pre_syscall ();
       do
         {
-          bytes_written = write (file_cookie->fd, buffer, size);
+          bytes_written = _write (file_cookie->fd, buffer, size);
         }
       while (bytes_written == -1 && errno == EINTR);
       _gpgrt_post_syscall ();
@@ -1003,7 +1011,7 @@ func_fd_seek (void *cookie, gpgrt_off_t *offset, int whence)
   else
     {
       _gpgrt_pre_syscall ();
-      offset_new = lseek (file_cookie->fd, *offset, whence);
+      offset_new = _lseek (file_cookie->fd, *offset, whence);
       _gpgrt_post_syscall ();
       if (offset_new == -1)
         err = -1;
@@ -1077,7 +1085,7 @@ func_fd_destroy (void *cookie)
       if (IS_INVALID_FD (fd_cookie->fd))
         err = 0;
       else
-        err = fd_cookie->no_close? 0 : close (fd_cookie->fd);
+        err = fd_cookie->no_close? 0 : _close (fd_cookie->fd);
       mem_free (fd_cookie);
     }
   else
@@ -1182,7 +1190,7 @@ func_w32_read (void *cookie, void *buffer, size_t size)
           DWORD nread, ec;
 
           trace (("cookie=%p calling ReadFile", cookie));
-          if (!ReadFile (w32_cookie->hd, buffer, size, &nread, NULL))
+          if (!ReadFile (w32_cookie->hd, buffer, (DWORD)size, &nread, NULL))
             {
               ec = GetLastError ();
               trace (("cookie=%p ReadFile failed: ec=%ld", cookie,ec));
@@ -1235,7 +1243,7 @@ func_w32_write (void *cookie, const void *buffer, size_t size)
           DWORD nwritten;
 
           trace (("cookie=%p calling WriteFile", cookie));
-	  if (!WriteFile (w32_cookie->hd, buffer, size, &nwritten, NULL))
+	  if (!WriteFile (w32_cookie->hd, buffer, (DWORD)size, &nwritten, NULL))
 	    {
               DWORD ec = GetLastError ();
               trace (("cookie=%p WriteFile failed: ec=%ld", cookie, ec));
@@ -1601,7 +1609,7 @@ func_file_create (void **cookie, int *filedes,
       goto out;
     }
 
-  fd = open (path, modeflags, cmode);
+  fd = _open (path, modeflags, cmode);
   if (fd == -1)
     {
       err = -1;
@@ -1610,7 +1618,7 @@ func_file_create (void **cookie, int *filedes,
 #ifdef HAVE_DOSISH_SYSTEM
   /* Make sure it is in binary mode if requested.  */
   if ( (modeflags & O_BINARY) )
-    setmode (fd, O_BINARY);
+    _setmode (fd, O_BINARY);
 #endif
 
   file_cookie->fd = fd;
@@ -1871,7 +1879,7 @@ fill_stream (estream_t stream)
   else if (!bytes_read)
     stream->intern->indicators.eof = 1;
 
-  stream->intern->offset += stream->data_len;
+  stream->intern->offset += (gpgrt_off_t)stream->data_len;
   stream->data_len = bytes_read;
   stream->data_offset = 0;
 
@@ -1934,7 +1942,7 @@ flush_stream (estream_t stream)
       stream->data_flushed += data_flushed;
       if (stream->data_offset == data_flushed)
 	{
-	  stream->intern->offset += stream->data_offset;
+	  stream->intern->offset += (gpgrt_off_t)stream->data_offset;
 	  stream->data_offset = 0;
 	  stream->data_flushed = 0;
 	}
@@ -2275,7 +2283,7 @@ do_read_nbf (estream_t _GPGRT__RESTRICT stream,
 	break;
     }
 
-  stream->intern->offset += data_read;
+  stream->intern->offset += (gpgrt_off_t)data_read;
   *bytes_read = data_read;
 
   return err;
@@ -2547,7 +2555,7 @@ es_seek (estream_t _GPGRT__RESTRICT stream, gpgrt_off_t offset, int whence,
   off = offset;
   if (whence == SEEK_CUR)
     {
-      off = off - stream->data_len + stream->data_offset;
+      off = off - (gpgrt_off_t)stream->data_len + (gpgrt_off_t)stream->data_offset;
       off -= stream->unread_data_len;
     }
 
@@ -2627,7 +2635,7 @@ es_write_nbf (estream_t _GPGRT__RESTRICT stream,
 	data_written += ret;
     }
 
-  stream->intern->offset += data_written;
+  stream->intern->offset += (gpgrt_off_t)data_written;
   *bytes_written = data_written;
 
  out:
@@ -3059,12 +3067,12 @@ es_offset_calculate (estream_t stream)
 {
   gpgrt_off_t offset;
 
-  offset = stream->intern->offset + stream->data_offset;
+  offset = stream->intern->offset + (gpgrt_off_t)stream->data_offset;
   if (offset < stream->unread_data_len)
     /* Offset undefined.  */
     offset = 0;
   else
-    offset -= stream->unread_data_len;
+    offset -= (gpgrt_off_t)stream->unread_data_len;
 
   return offset;
 }
@@ -4505,15 +4513,9 @@ tmpfd (void)
 {
 #ifdef HAVE_W32_SYSTEM
   int attempts, n;
-#ifdef HAVE_W32CE_SYSTEM
   wchar_t buffer[MAX_PATH+9+12+1];
 # define mystrlen(a) wcslen (a)
   wchar_t *name, *p;
-#else
-  char buffer[MAX_PATH+9+12+1];
-# define mystrlen(a) strlen (a)
-  char *name, *p;
-#endif
   HANDLE file;
   int pid = GetCurrentProcessId ();
   unsigned int value;
@@ -4526,11 +4528,7 @@ tmpfd (void)
       return -1;
     }
   p = buffer + mystrlen (buffer);
-#ifdef HAVE_W32CE_SYSTEM
   wcscpy (p, L"_estream");
-#else
-  strcpy (p, "_estream");
-#endif
   p += 8;
   /* We try to create the directory but don't care about an error as
      it may already exist and the CreateFile would throw an error
@@ -4547,30 +4545,35 @@ tmpfd (void)
           *p++ = tohex (((value >> 28) & 0x0f));
           value <<= 4;
         }
-#ifdef HAVE_W32CE_SYSTEM
       wcscpy (p, L".tmp");
+
+#ifdef MS_APP
+	  CREATEFILE2_EXTENDED_PARAMETERS params;
+	  params.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);
+	  params.dwFileAttributes = FILE_ATTRIBUTE_TEMPORARY;
+	  params.dwFileFlags = FILE_FLAG_DELETE_ON_CLOSE;
+      file = CreateFile2 (buffer,
+                         GENERIC_READ | GENERIC_WRITE,
+                         0,
+                         CREATE_NEW,
+                         &params);
 #else
-      strcpy (p, ".tmp");
-#endif
-      file = CreateFile (buffer,
+      file = CreateFileW (buffer,
                          GENERIC_READ | GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_NEW,
                          FILE_ATTRIBUTE_TEMPORARY | FILE_FLAG_DELETE_ON_CLOSE,
                          NULL);
+#endif
       if (file != INVALID_HANDLE_VALUE)
         {
-#ifdef HAVE_W32CE_SYSTEM
-          int fd = (int)file;
-#else
-          int fd = _open_osfhandle ((long)file, 0);
+          int fd = _open_osfhandle ((intptr_t)file, 0);
           if (fd == -1)
             {
               CloseHandle (file);
               return -1;
             }
-#endif
           return fd;
         }
       Sleep (1); /* One ms as this is the granularity of GetTickCount.  */
diff --git a/src/gettext.h b/src/gettext.h
index aba29db..74eb5f0 100644
--- a/src/gettext.h
+++ b/src/gettext.h
@@ -19,12 +19,15 @@
 #ifndef _LIBGETTEXT_H
 #define _LIBGETTEXT_H 1
 
+#include "config.h"
+
 /* NLS can be disabled through the configure --disable-nls option.  */
 #if ENABLE_NLS
 
 #if HAVE_W32_SYSTEM
   /* We have a gettext implementation in gpg-error.h which get
      included anyway.  */
+#include "w32-add.h"
 #else /*!HAVE_W32_SYSTEM*/
   /* Get declarations of GNU message catalog functions.  */
 # include <libintl.h>
diff --git a/src/gpg-error.h b/src/gpg-error.h
new file mode 100644
index 0000000..4273a41
--- /dev/null
+++ b/src/gpg-error.h
@@ -0,0 +1,1900 @@
+/* gpg-error.h or gpgrt.h - Common code for GnuPG and others.    -*- c -*-
+ * Copyright (C) 2001-2019 g10 Code GmbH
+ *
+ * This file is part of libgpg-error (aka libgpgrt).
+ *
+ * libgpg-error is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation; either version 2.1 of
+ * the License, or (at your option) any later version.
+ *
+ * libgpg-error is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this program; if not, see <https://www.gnu.org/licenses/>.
+ * SPDX-License-Identifier: LGPL-2.1+
+ *
+ * Do not edit.  Generated from gpg-error.h.in for:
+                 x86_64-unknown-linux-gnu (x86_64-pc-linux-gnu)
+ */
+
+/* The GnuPG project consists of many components.  Error codes are
+ * exchanged between all components.  The common error codes and their
+ * user-presentable descriptions are kept into a shared library to
+ * allow adding new error codes and components without recompiling any
+ * of the other components.  In addition to error codes this library
+ * also features several other groups of functions which are common to
+ * all GnuPG components.  They may be used by independet project as
+ * well.  The interfaces will not change in a backward incompatible way.
+ *
+ * An error code together with an error source build up an error
+ * value.  As the error value is been passed from one component to
+ * another, it preserves the information about the source and nature
+ * of the error.
+ *
+ * A component of the GnuPG project can define the following macros to
+ * tune the behaviour of the library:
+ *
+ * GPG_ERR_SOURCE_DEFAULT: Define to an error source of type
+ * gpg_err_source_t to make that source the default for gpg_error().
+ * Otherwise GPG_ERR_SOURCE_UNKNOWN is used as default.
+ *
+ * GPG_ERR_ENABLE_GETTEXT_MACROS: Define to provide macros to map the
+ * internal gettext API to standard names.  This has only an effect on
+ * Windows platforms.
+ *
+ * GPGRT_ENABLE_ES_MACROS: Define to provide "es_" macros for the
+ * estream functions.
+ *
+ * GPGRT_ENABLE_LOG_MACROS: Define to provide short versions of the
+ * log functions.
+ *
+ * GPGRT_ENABLE_ARGPARSE_MACROS: Needs to be defined to provide the
+ * mandatory macros of the argparse interface.
+ */
+
+#ifndef GPG_ERROR_H
+#define GPG_ERROR_H 1
+#ifndef GPGRT_H
+#define GPGRT_H 1
+
+#include <stddef.h>
+#include <stdio.h>
+#include <stdarg.h>
+
+/* The version string of this header. */
+#define GPG_ERROR_VERSION "1.36"
+#define GPGRT_VERSION     "1.36"
+
+/* The version number of this header. */
+#define GPG_ERROR_VERSION_NUMBER 0x012400
+#define GPGRT_VERSION_NUMBER     0x012400
+
+
+#ifdef __GNUC__
+# define GPG_ERR_INLINE __inline__
+#elif defined(_MSC_VER) && _MSC_VER >= 1300
+# define GPG_ERR_INLINE __inline
+#elif defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+# define GPG_ERR_INLINE inline
+#else
+# ifndef GPG_ERR_INLINE
+#  define GPG_ERR_INLINE
+# endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#if 0 /* just to make Emacs auto-indent happy */
+}
+#endif
+#endif /* __cplusplus */
+
+
+
+/* The error source type gpg_err_source_t.
+ *
+ * Where as the Poo out of a welle small
+ * Taketh his firste springing and his sours.
+ *					--Chaucer.
+ */
+
+/* Only use free slots, never change or reorder the existing
+ * entries.  */
+typedef enum
+  {
+    GPG_ERR_SOURCE_UNKNOWN = 0,
+    GPG_ERR_SOURCE_GCRYPT = 1,
+    GPG_ERR_SOURCE_GPG = 2,
+    GPG_ERR_SOURCE_GPGSM = 3,
+    GPG_ERR_SOURCE_GPGAGENT = 4,
+    GPG_ERR_SOURCE_PINENTRY = 5,
+    GPG_ERR_SOURCE_SCD = 6,
+    GPG_ERR_SOURCE_GPGME = 7,
+    GPG_ERR_SOURCE_KEYBOX = 8,
+    GPG_ERR_SOURCE_KSBA = 9,
+    GPG_ERR_SOURCE_DIRMNGR = 10,
+    GPG_ERR_SOURCE_GSTI = 11,
+    GPG_ERR_SOURCE_GPA = 12,
+    GPG_ERR_SOURCE_KLEO = 13,
+    GPG_ERR_SOURCE_G13 = 14,
+    GPG_ERR_SOURCE_ASSUAN = 15,
+    GPG_ERR_SOURCE_TLS = 17,
+    GPG_ERR_SOURCE_ANY = 31,
+    GPG_ERR_SOURCE_USER_1 = 32,
+    GPG_ERR_SOURCE_USER_2 = 33,
+    GPG_ERR_SOURCE_USER_3 = 34,
+    GPG_ERR_SOURCE_USER_4 = 35,
+
+    /* This is one more than the largest allowed entry.  */
+    GPG_ERR_SOURCE_DIM = 128
+  } gpg_err_source_t;
+
+
+/* The error code type gpg_err_code_t.  */
+
+/* Only use free slots, never change or reorder the existing
+ * entries.  */
+typedef enum
+  {
+    GPG_ERR_NO_ERROR = 0,
+    GPG_ERR_GENERAL = 1,
+    GPG_ERR_UNKNOWN_PACKET = 2,
+    GPG_ERR_UNKNOWN_VERSION = 3,
+    GPG_ERR_PUBKEY_ALGO = 4,
+    GPG_ERR_DIGEST_ALGO = 5,
+    GPG_ERR_BAD_PUBKEY = 6,
+    GPG_ERR_BAD_SECKEY = 7,
+    GPG_ERR_BAD_SIGNATURE = 8,
+    GPG_ERR_NO_PUBKEY = 9,
+    GPG_ERR_CHECKSUM = 10,
+    GPG_ERR_BAD_PASSPHRASE = 11,
+    GPG_ERR_CIPHER_ALGO = 12,
+    GPG_ERR_KEYRING_OPEN = 13,
+    GPG_ERR_INV_PACKET = 14,
+    GPG_ERR_INV_ARMOR = 15,
+    GPG_ERR_NO_USER_ID = 16,
+    GPG_ERR_NO_SECKEY = 17,
+    GPG_ERR_WRONG_SECKEY = 18,
+    GPG_ERR_BAD_KEY = 19,
+    GPG_ERR_COMPR_ALGO = 20,
+    GPG_ERR_NO_PRIME = 21,
+    GPG_ERR_NO_ENCODING_METHOD = 22,
+    GPG_ERR_NO_ENCRYPTION_SCHEME = 23,
+    GPG_ERR_NO_SIGNATURE_SCHEME = 24,
+    GPG_ERR_INV_ATTR = 25,
+    GPG_ERR_NO_VALUE = 26,
+    GPG_ERR_NOT_FOUND = 27,
+    GPG_ERR_VALUE_NOT_FOUND = 28,
+    GPG_ERR_SYNTAX = 29,
+    GPG_ERR_BAD_MPI = 30,
+    GPG_ERR_INV_PASSPHRASE = 31,
+    GPG_ERR_SIG_CLASS = 32,
+    GPG_ERR_RESOURCE_LIMIT = 33,
+    GPG_ERR_INV_KEYRING = 34,
+    GPG_ERR_TRUSTDB = 35,
+    GPG_ERR_BAD_CERT = 36,
+    GPG_ERR_INV_USER_ID = 37,
+    GPG_ERR_UNEXPECTED = 38,
+    GPG_ERR_TIME_CONFLICT = 39,
+    GPG_ERR_KEYSERVER = 40,
+    GPG_ERR_WRONG_PUBKEY_ALGO = 41,
+    GPG_ERR_TRIBUTE_TO_D_A = 42,
+    GPG_ERR_WEAK_KEY = 43,
+    GPG_ERR_INV_KEYLEN = 44,
+    GPG_ERR_INV_ARG = 45,
+    GPG_ERR_BAD_URI = 46,
+    GPG_ERR_INV_URI = 47,
+    GPG_ERR_NETWORK = 48,
+    GPG_ERR_UNKNOWN_HOST = 49,
+    GPG_ERR_SELFTEST_FAILED = 50,
+    GPG_ERR_NOT_ENCRYPTED = 51,
+    GPG_ERR_NOT_PROCESSED = 52,
+    GPG_ERR_UNUSABLE_PUBKEY = 53,
+    GPG_ERR_UNUSABLE_SECKEY = 54,
+    GPG_ERR_INV_VALUE = 55,
+    GPG_ERR_BAD_CERT_CHAIN = 56,
+    GPG_ERR_MISSING_CERT = 57,
+    GPG_ERR_NO_DATA = 58,
+    GPG_ERR_BUG = 59,
+    GPG_ERR_NOT_SUPPORTED = 60,
+    GPG_ERR_INV_OP = 61,
+    GPG_ERR_TIMEOUT = 62,
+    GPG_ERR_INTERNAL = 63,
+    GPG_ERR_EOF_GCRYPT = 64,
+    GPG_ERR_INV_OBJ = 65,
+    GPG_ERR_TOO_SHORT = 66,
+    GPG_ERR_TOO_LARGE = 67,
+    GPG_ERR_NO_OBJ = 68,
+    GPG_ERR_NOT_IMPLEMENTED = 69,
+    GPG_ERR_CONFLICT = 70,
+    GPG_ERR_INV_CIPHER_MODE = 71,
+    GPG_ERR_INV_FLAG = 72,
+    GPG_ERR_INV_HANDLE = 73,
+    GPG_ERR_TRUNCATED = 74,
+    GPG_ERR_INCOMPLETE_LINE = 75,
+    GPG_ERR_INV_RESPONSE = 76,
+    GPG_ERR_NO_AGENT = 77,
+    GPG_ERR_AGENT = 78,
+    GPG_ERR_INV_DATA = 79,
+    GPG_ERR_ASSUAN_SERVER_FAULT = 80,
+    GPG_ERR_ASSUAN = 81,
+    GPG_ERR_INV_SESSION_KEY = 82,
+    GPG_ERR_INV_SEXP = 83,
+    GPG_ERR_UNSUPPORTED_ALGORITHM = 84,
+    GPG_ERR_NO_PIN_ENTRY = 85,
+    GPG_ERR_PIN_ENTRY = 86,
+    GPG_ERR_BAD_PIN = 87,
+    GPG_ERR_INV_NAME = 88,
+    GPG_ERR_BAD_DATA = 89,
+    GPG_ERR_INV_PARAMETER = 90,
+    GPG_ERR_WRONG_CARD = 91,
+    GPG_ERR_NO_DIRMNGR = 92,
+    GPG_ERR_DIRMNGR = 93,
+    GPG_ERR_CERT_REVOKED = 94,
+    GPG_ERR_NO_CRL_KNOWN = 95,
+    GPG_ERR_CRL_TOO_OLD = 96,
+    GPG_ERR_LINE_TOO_LONG = 97,
+    GPG_ERR_NOT_TRUSTED = 98,
+    GPG_ERR_CANCELED = 99,
+    GPG_ERR_BAD_CA_CERT = 100,
+    GPG_ERR_CERT_EXPIRED = 101,
+    GPG_ERR_CERT_TOO_YOUNG = 102,
+    GPG_ERR_UNSUPPORTED_CERT = 103,
+    GPG_ERR_UNKNOWN_SEXP = 104,
+    GPG_ERR_UNSUPPORTED_PROTECTION = 105,
+    GPG_ERR_CORRUPTED_PROTECTION = 106,
+    GPG_ERR_AMBIGUOUS_NAME = 107,
+    GPG_ERR_CARD = 108,
+    GPG_ERR_CARD_RESET = 109,
+    GPG_ERR_CARD_REMOVED = 110,
+    GPG_ERR_INV_CARD = 111,
+    GPG_ERR_CARD_NOT_PRESENT = 112,
+    GPG_ERR_NO_PKCS15_APP = 113,
+    GPG_ERR_NOT_CONFIRMED = 114,
+    GPG_ERR_CONFIGURATION = 115,
+    GPG_ERR_NO_POLICY_MATCH = 116,
+    GPG_ERR_INV_INDEX = 117,
+    GPG_ERR_INV_ID = 118,
+    GPG_ERR_NO_SCDAEMON = 119,
+    GPG_ERR_SCDAEMON = 120,
+    GPG_ERR_UNSUPPORTED_PROTOCOL = 121,
+    GPG_ERR_BAD_PIN_METHOD = 122,
+    GPG_ERR_CARD_NOT_INITIALIZED = 123,
+    GPG_ERR_UNSUPPORTED_OPERATION = 124,
+    GPG_ERR_WRONG_KEY_USAGE = 125,
+    GPG_ERR_NOTHING_FOUND = 126,
+    GPG_ERR_WRONG_BLOB_TYPE = 127,
+    GPG_ERR_MISSING_VALUE = 128,
+    GPG_ERR_HARDWARE = 129,
+    GPG_ERR_PIN_BLOCKED = 130,
+    GPG_ERR_USE_CONDITIONS = 131,
+    GPG_ERR_PIN_NOT_SYNCED = 132,
+    GPG_ERR_INV_CRL = 133,
+    GPG_ERR_BAD_BER = 134,
+    GPG_ERR_INV_BER = 135,
+    GPG_ERR_ELEMENT_NOT_FOUND = 136,
+    GPG_ERR_IDENTIFIER_NOT_FOUND = 137,
+    GPG_ERR_INV_TAG = 138,
+    GPG_ERR_INV_LENGTH = 139,
+    GPG_ERR_INV_KEYINFO = 140,
+    GPG_ERR_UNEXPECTED_TAG = 141,
+    GPG_ERR_NOT_DER_ENCODED = 142,
+    GPG_ERR_NO_CMS_OBJ = 143,
+    GPG_ERR_INV_CMS_OBJ = 144,
+    GPG_ERR_UNKNOWN_CMS_OBJ = 145,
+    GPG_ERR_UNSUPPORTED_CMS_OBJ = 146,
+    GPG_ERR_UNSUPPORTED_ENCODING = 147,
+    GPG_ERR_UNSUPPORTED_CMS_VERSION = 148,
+    GPG_ERR_UNKNOWN_ALGORITHM = 149,
+    GPG_ERR_INV_ENGINE = 150,
+    GPG_ERR_PUBKEY_NOT_TRUSTED = 151,
+    GPG_ERR_DECRYPT_FAILED = 152,
+    GPG_ERR_KEY_EXPIRED = 153,
+    GPG_ERR_SIG_EXPIRED = 154,
+    GPG_ERR_ENCODING_PROBLEM = 155,
+    GPG_ERR_INV_STATE = 156,
+    GPG_ERR_DUP_VALUE = 157,
+    GPG_ERR_MISSING_ACTION = 158,
+    GPG_ERR_MODULE_NOT_FOUND = 159,
+    GPG_ERR_INV_OID_STRING = 160,
+    GPG_ERR_INV_TIME = 161,
+    GPG_ERR_INV_CRL_OBJ = 162,
+    GPG_ERR_UNSUPPORTED_CRL_VERSION = 163,
+    GPG_ERR_INV_CERT_OBJ = 164,
+    GPG_ERR_UNKNOWN_NAME = 165,
+    GPG_ERR_LOCALE_PROBLEM = 166,
+    GPG_ERR_NOT_LOCKED = 167,
+    GPG_ERR_PROTOCOL_VIOLATION = 168,
+    GPG_ERR_INV_MAC = 169,
+    GPG_ERR_INV_REQUEST = 170,
+    GPG_ERR_UNKNOWN_EXTN = 171,
+    GPG_ERR_UNKNOWN_CRIT_EXTN = 172,
+    GPG_ERR_LOCKED = 173,
+    GPG_ERR_UNKNOWN_OPTION = 174,
+    GPG_ERR_UNKNOWN_COMMAND = 175,
+    GPG_ERR_NOT_OPERATIONAL = 176,
+    GPG_ERR_NO_PASSPHRASE = 177,
+    GPG_ERR_NO_PIN = 178,
+    GPG_ERR_NOT_ENABLED = 179,
+    GPG_ERR_NO_ENGINE = 180,
+    GPG_ERR_MISSING_KEY = 181,
+    GPG_ERR_TOO_MANY = 182,
+    GPG_ERR_LIMIT_REACHED = 183,
+    GPG_ERR_NOT_INITIALIZED = 184,
+    GPG_ERR_MISSING_ISSUER_CERT = 185,
+    GPG_ERR_NO_KEYSERVER = 186,
+    GPG_ERR_INV_CURVE = 187,
+    GPG_ERR_UNKNOWN_CURVE = 188,
+    GPG_ERR_DUP_KEY = 189,
+    GPG_ERR_AMBIGUOUS = 190,
+    GPG_ERR_NO_CRYPT_CTX = 191,
+    GPG_ERR_WRONG_CRYPT_CTX = 192,
+    GPG_ERR_BAD_CRYPT_CTX = 193,
+    GPG_ERR_CRYPT_CTX_CONFLICT = 194,
+    GPG_ERR_BROKEN_PUBKEY = 195,
+    GPG_ERR_BROKEN_SECKEY = 196,
+    GPG_ERR_MAC_ALGO = 197,
+    GPG_ERR_FULLY_CANCELED = 198,
+    GPG_ERR_UNFINISHED = 199,
+    GPG_ERR_BUFFER_TOO_SHORT = 200,
+    GPG_ERR_SEXP_INV_LEN_SPEC = 201,
+    GPG_ERR_SEXP_STRING_TOO_LONG = 202,
+    GPG_ERR_SEXP_UNMATCHED_PAREN = 203,
+    GPG_ERR_SEXP_NOT_CANONICAL = 204,
+    GPG_ERR_SEXP_BAD_CHARACTER = 205,
+    GPG_ERR_SEXP_BAD_QUOTATION = 206,
+    GPG_ERR_SEXP_ZERO_PREFIX = 207,
+    GPG_ERR_SEXP_NESTED_DH = 208,
+    GPG_ERR_SEXP_UNMATCHED_DH = 209,
+    GPG_ERR_SEXP_UNEXPECTED_PUNC = 210,
+    GPG_ERR_SEXP_BAD_HEX_CHAR = 211,
+    GPG_ERR_SEXP_ODD_HEX_NUMBERS = 212,
+    GPG_ERR_SEXP_BAD_OCT_CHAR = 213,
+    GPG_ERR_SUBKEYS_EXP_OR_REV = 217,
+    GPG_ERR_DB_CORRUPTED = 218,
+    GPG_ERR_SERVER_FAILED = 219,
+    GPG_ERR_NO_NAME = 220,
+    GPG_ERR_NO_KEY = 221,
+    GPG_ERR_LEGACY_KEY = 222,
+    GPG_ERR_REQUEST_TOO_SHORT = 223,
+    GPG_ERR_REQUEST_TOO_LONG = 224,
+    GPG_ERR_OBJ_TERM_STATE = 225,
+    GPG_ERR_NO_CERT_CHAIN = 226,
+    GPG_ERR_CERT_TOO_LARGE = 227,
+    GPG_ERR_INV_RECORD = 228,
+    GPG_ERR_BAD_MAC = 229,
+    GPG_ERR_UNEXPECTED_MSG = 230,
+    GPG_ERR_COMPR_FAILED = 231,
+    GPG_ERR_WOULD_WRAP = 232,
+    GPG_ERR_FATAL_ALERT = 233,
+    GPG_ERR_NO_CIPHER = 234,
+    GPG_ERR_MISSING_CLIENT_CERT = 235,
+    GPG_ERR_CLOSE_NOTIFY = 236,
+    GPG_ERR_TICKET_EXPIRED = 237,
+    GPG_ERR_BAD_TICKET = 238,
+    GPG_ERR_UNKNOWN_IDENTITY = 239,
+    GPG_ERR_BAD_HS_CERT = 240,
+    GPG_ERR_BAD_HS_CERT_REQ = 241,
+    GPG_ERR_BAD_HS_CERT_VER = 242,
+    GPG_ERR_BAD_HS_CHANGE_CIPHER = 243,
+    GPG_ERR_BAD_HS_CLIENT_HELLO = 244,
+    GPG_ERR_BAD_HS_SERVER_HELLO = 245,
+    GPG_ERR_BAD_HS_SERVER_HELLO_DONE = 246,
+    GPG_ERR_BAD_HS_FINISHED = 247,
+    GPG_ERR_BAD_HS_SERVER_KEX = 248,
+    GPG_ERR_BAD_HS_CLIENT_KEX = 249,
+    GPG_ERR_BOGUS_STRING = 250,
+    GPG_ERR_FORBIDDEN = 251,
+    GPG_ERR_KEY_DISABLED = 252,
+    GPG_ERR_KEY_ON_CARD = 253,
+    GPG_ERR_INV_LOCK_OBJ = 254,
+    GPG_ERR_TRUE = 255,
+    GPG_ERR_FALSE = 256,
+    GPG_ERR_ASS_GENERAL = 257,
+    GPG_ERR_ASS_ACCEPT_FAILED = 258,
+    GPG_ERR_ASS_CONNECT_FAILED = 259,
+    GPG_ERR_ASS_INV_RESPONSE = 260,
+    GPG_ERR_ASS_INV_VALUE = 261,
+    GPG_ERR_ASS_INCOMPLETE_LINE = 262,
+    GPG_ERR_ASS_LINE_TOO_LONG = 263,
+    GPG_ERR_ASS_NESTED_COMMANDS = 264,
+    GPG_ERR_ASS_NO_DATA_CB = 265,
+    GPG_ERR_ASS_NO_INQUIRE_CB = 266,
+    GPG_ERR_ASS_NOT_A_SERVER = 267,
+    GPG_ERR_ASS_NOT_A_CLIENT = 268,
+    GPG_ERR_ASS_SERVER_START = 269,
+    GPG_ERR_ASS_READ_ERROR = 270,
+    GPG_ERR_ASS_WRITE_ERROR = 271,
+    GPG_ERR_ASS_TOO_MUCH_DATA = 273,
+    GPG_ERR_ASS_UNEXPECTED_CMD = 274,
+    GPG_ERR_ASS_UNKNOWN_CMD = 275,
+    GPG_ERR_ASS_SYNTAX = 276,
+    GPG_ERR_ASS_CANCELED = 277,
+    GPG_ERR_ASS_NO_INPUT = 278,
+    GPG_ERR_ASS_NO_OUTPUT = 279,
+    GPG_ERR_ASS_PARAMETER = 280,
+    GPG_ERR_ASS_UNKNOWN_INQUIRE = 281,
+    GPG_ERR_ENGINE_TOO_OLD = 300,
+    GPG_ERR_WINDOW_TOO_SMALL = 301,
+    GPG_ERR_WINDOW_TOO_LARGE = 302,
+    GPG_ERR_MISSING_ENVVAR = 303,
+    GPG_ERR_USER_ID_EXISTS = 304,
+    GPG_ERR_NAME_EXISTS = 305,
+    GPG_ERR_DUP_NAME = 306,
+    GPG_ERR_TOO_YOUNG = 307,
+    GPG_ERR_TOO_OLD = 308,
+    GPG_ERR_UNKNOWN_FLAG = 309,
+    GPG_ERR_INV_ORDER = 310,
+    GPG_ERR_ALREADY_FETCHED = 311,
+    GPG_ERR_TRY_LATER = 312,
+    GPG_ERR_WRONG_NAME = 313,
+    GPG_ERR_NO_AUTH = 314,
+    GPG_ERR_BAD_AUTH = 315,
+    GPG_ERR_SYSTEM_BUG = 666,
+    GPG_ERR_DNS_UNKNOWN = 711,
+    GPG_ERR_DNS_SECTION = 712,
+    GPG_ERR_DNS_ADDRESS = 713,
+    GPG_ERR_DNS_NO_QUERY = 714,
+    GPG_ERR_DNS_NO_ANSWER = 715,
+    GPG_ERR_DNS_CLOSED = 716,
+    GPG_ERR_DNS_VERIFY = 717,
+    GPG_ERR_DNS_TIMEOUT = 718,
+    GPG_ERR_LDAP_GENERAL = 721,
+    GPG_ERR_LDAP_ATTR_GENERAL = 722,
+    GPG_ERR_LDAP_NAME_GENERAL = 723,
+    GPG_ERR_LDAP_SECURITY_GENERAL = 724,
+    GPG_ERR_LDAP_SERVICE_GENERAL = 725,
+    GPG_ERR_LDAP_UPDATE_GENERAL = 726,
+    GPG_ERR_LDAP_E_GENERAL = 727,
+    GPG_ERR_LDAP_X_GENERAL = 728,
+    GPG_ERR_LDAP_OTHER_GENERAL = 729,
+    GPG_ERR_LDAP_X_CONNECTING = 750,
+    GPG_ERR_LDAP_REFERRAL_LIMIT = 751,
+    GPG_ERR_LDAP_CLIENT_LOOP = 752,
+    GPG_ERR_LDAP_NO_RESULTS = 754,
+    GPG_ERR_LDAP_CONTROL_NOT_FOUND = 755,
+    GPG_ERR_LDAP_NOT_SUPPORTED = 756,
+    GPG_ERR_LDAP_CONNECT = 757,
+    GPG_ERR_LDAP_NO_MEMORY = 758,
+    GPG_ERR_LDAP_PARAM = 759,
+    GPG_ERR_LDAP_USER_CANCELLED = 760,
+    GPG_ERR_LDAP_FILTER = 761,
+    GPG_ERR_LDAP_AUTH_UNKNOWN = 762,
+    GPG_ERR_LDAP_TIMEOUT = 763,
+    GPG_ERR_LDAP_DECODING = 764,
+    GPG_ERR_LDAP_ENCODING = 765,
+    GPG_ERR_LDAP_LOCAL = 766,
+    GPG_ERR_LDAP_SERVER_DOWN = 767,
+    GPG_ERR_LDAP_SUCCESS = 768,
+    GPG_ERR_LDAP_OPERATIONS = 769,
+    GPG_ERR_LDAP_PROTOCOL = 770,
+    GPG_ERR_LDAP_TIMELIMIT = 771,
+    GPG_ERR_LDAP_SIZELIMIT = 772,
+    GPG_ERR_LDAP_COMPARE_FALSE = 773,
+    GPG_ERR_LDAP_COMPARE_TRUE = 774,
+    GPG_ERR_LDAP_UNSUPPORTED_AUTH = 775,
+    GPG_ERR_LDAP_STRONG_AUTH_RQRD = 776,
+    GPG_ERR_LDAP_PARTIAL_RESULTS = 777,
+    GPG_ERR_LDAP_REFERRAL = 778,
+    GPG_ERR_LDAP_ADMINLIMIT = 779,
+    GPG_ERR_LDAP_UNAVAIL_CRIT_EXTN = 780,
+    GPG_ERR_LDAP_CONFIDENT_RQRD = 781,
+    GPG_ERR_LDAP_SASL_BIND_INPROG = 782,
+    GPG_ERR_LDAP_NO_SUCH_ATTRIBUTE = 784,
+    GPG_ERR_LDAP_UNDEFINED_TYPE = 785,
+    GPG_ERR_LDAP_BAD_MATCHING = 786,
+    GPG_ERR_LDAP_CONST_VIOLATION = 787,
+    GPG_ERR_LDAP_TYPE_VALUE_EXISTS = 788,
+    GPG_ERR_LDAP_INV_SYNTAX = 789,
+    GPG_ERR_LDAP_NO_SUCH_OBJ = 800,
+    GPG_ERR_LDAP_ALIAS_PROBLEM = 801,
+    GPG_ERR_LDAP_INV_DN_SYNTAX = 802,
+    GPG_ERR_LDAP_IS_LEAF = 803,
+    GPG_ERR_LDAP_ALIAS_DEREF = 804,
+    GPG_ERR_LDAP_X_PROXY_AUTH_FAIL = 815,
+    GPG_ERR_LDAP_BAD_AUTH = 816,
+    GPG_ERR_LDAP_INV_CREDENTIALS = 817,
+    GPG_ERR_LDAP_INSUFFICIENT_ACC = 818,
+    GPG_ERR_LDAP_BUSY = 819,
+    GPG_ERR_LDAP_UNAVAILABLE = 820,
+    GPG_ERR_LDAP_UNWILL_TO_PERFORM = 821,
+    GPG_ERR_LDAP_LOOP_DETECT = 822,
+    GPG_ERR_LDAP_NAMING_VIOLATION = 832,
+    GPG_ERR_LDAP_OBJ_CLS_VIOLATION = 833,
+    GPG_ERR_LDAP_NOT_ALLOW_NONLEAF = 834,
+    GPG_ERR_LDAP_NOT_ALLOW_ON_RDN = 835,
+    GPG_ERR_LDAP_ALREADY_EXISTS = 836,
+    GPG_ERR_LDAP_NO_OBJ_CLASS_MODS = 837,
+    GPG_ERR_LDAP_RESULTS_TOO_LARGE = 838,
+    GPG_ERR_LDAP_AFFECTS_MULT_DSAS = 839,
+    GPG_ERR_LDAP_VLV = 844,
+    GPG_ERR_LDAP_OTHER = 848,
+    GPG_ERR_LDAP_CUP_RESOURCE_LIMIT = 881,
+    GPG_ERR_LDAP_CUP_SEC_VIOLATION = 882,
+    GPG_ERR_LDAP_CUP_INV_DATA = 883,
+    GPG_ERR_LDAP_CUP_UNSUP_SCHEME = 884,
+    GPG_ERR_LDAP_CUP_RELOAD = 885,
+    GPG_ERR_LDAP_CANCELLED = 886,
+    GPG_ERR_LDAP_NO_SUCH_OPERATION = 887,
+    GPG_ERR_LDAP_TOO_LATE = 888,
+    GPG_ERR_LDAP_CANNOT_CANCEL = 889,
+    GPG_ERR_LDAP_ASSERTION_FAILED = 890,
+    GPG_ERR_LDAP_PROX_AUTH_DENIED = 891,
+    GPG_ERR_USER_1 = 1024,
+    GPG_ERR_USER_2 = 1025,
+    GPG_ERR_USER_3 = 1026,
+    GPG_ERR_USER_4 = 1027,
+    GPG_ERR_USER_5 = 1028,
+    GPG_ERR_USER_6 = 1029,
+    GPG_ERR_USER_7 = 1030,
+    GPG_ERR_USER_8 = 1031,
+    GPG_ERR_USER_9 = 1032,
+    GPG_ERR_USER_10 = 1033,
+    GPG_ERR_USER_11 = 1034,
+    GPG_ERR_USER_12 = 1035,
+    GPG_ERR_USER_13 = 1036,
+    GPG_ERR_USER_14 = 1037,
+    GPG_ERR_USER_15 = 1038,
+    GPG_ERR_USER_16 = 1039,
+    GPG_ERR_MISSING_ERRNO = 16381,
+    GPG_ERR_UNKNOWN_ERRNO = 16382,
+    GPG_ERR_EOF = 16383,
+
+    /* The following error codes are used to map system errors.  */
+#define GPG_ERR_SYSTEM_ERROR	(1 << 15)
+    GPG_ERR_E2BIG = GPG_ERR_SYSTEM_ERROR | 0,
+    GPG_ERR_EACCES = GPG_ERR_SYSTEM_ERROR | 1,
+    GPG_ERR_EADDRINUSE = GPG_ERR_SYSTEM_ERROR | 2,
+    GPG_ERR_EADDRNOTAVAIL = GPG_ERR_SYSTEM_ERROR | 3,
+    GPG_ERR_EADV = GPG_ERR_SYSTEM_ERROR | 4,
+    GPG_ERR_EAFNOSUPPORT = GPG_ERR_SYSTEM_ERROR | 5,
+    GPG_ERR_EAGAIN = GPG_ERR_SYSTEM_ERROR | 6,
+    GPG_ERR_EALREADY = GPG_ERR_SYSTEM_ERROR | 7,
+    GPG_ERR_EAUTH = GPG_ERR_SYSTEM_ERROR | 8,
+    GPG_ERR_EBACKGROUND = GPG_ERR_SYSTEM_ERROR | 9,
+    GPG_ERR_EBADE = GPG_ERR_SYSTEM_ERROR | 10,
+    GPG_ERR_EBADF = GPG_ERR_SYSTEM_ERROR | 11,
+    GPG_ERR_EBADFD = GPG_ERR_SYSTEM_ERROR | 12,
+    GPG_ERR_EBADMSG = GPG_ERR_SYSTEM_ERROR | 13,
+    GPG_ERR_EBADR = GPG_ERR_SYSTEM_ERROR | 14,
+    GPG_ERR_EBADRPC = GPG_ERR_SYSTEM_ERROR | 15,
+    GPG_ERR_EBADRQC = GPG_ERR_SYSTEM_ERROR | 16,
+    GPG_ERR_EBADSLT = GPG_ERR_SYSTEM_ERROR | 17,
+    GPG_ERR_EBFONT = GPG_ERR_SYSTEM_ERROR | 18,
+    GPG_ERR_EBUSY = GPG_ERR_SYSTEM_ERROR | 19,
+    GPG_ERR_ECANCELED = GPG_ERR_SYSTEM_ERROR | 20,
+    GPG_ERR_ECHILD = GPG_ERR_SYSTEM_ERROR | 21,
+    GPG_ERR_ECHRNG = GPG_ERR_SYSTEM_ERROR | 22,
+    GPG_ERR_ECOMM = GPG_ERR_SYSTEM_ERROR | 23,
+    GPG_ERR_ECONNABORTED = GPG_ERR_SYSTEM_ERROR | 24,
+    GPG_ERR_ECONNREFUSED = GPG_ERR_SYSTEM_ERROR | 25,
+    GPG_ERR_ECONNRESET = GPG_ERR_SYSTEM_ERROR | 26,
+    GPG_ERR_ED = GPG_ERR_SYSTEM_ERROR | 27,
+    GPG_ERR_EDEADLK = GPG_ERR_SYSTEM_ERROR | 28,
+    GPG_ERR_EDEADLOCK = GPG_ERR_SYSTEM_ERROR | 29,
+    GPG_ERR_EDESTADDRREQ = GPG_ERR_SYSTEM_ERROR | 30,
+    GPG_ERR_EDIED = GPG_ERR_SYSTEM_ERROR | 31,
+    GPG_ERR_EDOM = GPG_ERR_SYSTEM_ERROR | 32,
+    GPG_ERR_EDOTDOT = GPG_ERR_SYSTEM_ERROR | 33,
+    GPG_ERR_EDQUOT = GPG_ERR_SYSTEM_ERROR | 34,
+    GPG_ERR_EEXIST = GPG_ERR_SYSTEM_ERROR | 35,
+    GPG_ERR_EFAULT = GPG_ERR_SYSTEM_ERROR | 36,
+    GPG_ERR_EFBIG = GPG_ERR_SYSTEM_ERROR | 37,
+    GPG_ERR_EFTYPE = GPG_ERR_SYSTEM_ERROR | 38,
+    GPG_ERR_EGRATUITOUS = GPG_ERR_SYSTEM_ERROR | 39,
+    GPG_ERR_EGREGIOUS = GPG_ERR_SYSTEM_ERROR | 40,
+    GPG_ERR_EHOSTDOWN = GPG_ERR_SYSTEM_ERROR | 41,
+    GPG_ERR_EHOSTUNREACH = GPG_ERR_SYSTEM_ERROR | 42,
+    GPG_ERR_EIDRM = GPG_ERR_SYSTEM_ERROR | 43,
+    GPG_ERR_EIEIO = GPG_ERR_SYSTEM_ERROR | 44,
+    GPG_ERR_EILSEQ = GPG_ERR_SYSTEM_ERROR | 45,
+    GPG_ERR_EINPROGRESS = GPG_ERR_SYSTEM_ERROR | 46,
+    GPG_ERR_EINTR = GPG_ERR_SYSTEM_ERROR | 47,
+    GPG_ERR_EINVAL = GPG_ERR_SYSTEM_ERROR | 48,
+    GPG_ERR_EIO = GPG_ERR_SYSTEM_ERROR | 49,
+    GPG_ERR_EISCONN = GPG_ERR_SYSTEM_ERROR | 50,
+    GPG_ERR_EISDIR = GPG_ERR_SYSTEM_ERROR | 51,
+    GPG_ERR_EISNAM = GPG_ERR_SYSTEM_ERROR | 52,
+    GPG_ERR_EL2HLT = GPG_ERR_SYSTEM_ERROR | 53,
+    GPG_ERR_EL2NSYNC = GPG_ERR_SYSTEM_ERROR | 54,
+    GPG_ERR_EL3HLT = GPG_ERR_SYSTEM_ERROR | 55,
+    GPG_ERR_EL3RST = GPG_ERR_SYSTEM_ERROR | 56,
+    GPG_ERR_ELIBACC = GPG_ERR_SYSTEM_ERROR | 57,
+    GPG_ERR_ELIBBAD = GPG_ERR_SYSTEM_ERROR | 58,
+    GPG_ERR_ELIBEXEC = GPG_ERR_SYSTEM_ERROR | 59,
+    GPG_ERR_ELIBMAX = GPG_ERR_SYSTEM_ERROR | 60,
+    GPG_ERR_ELIBSCN = GPG_ERR_SYSTEM_ERROR | 61,
+    GPG_ERR_ELNRNG = GPG_ERR_SYSTEM_ERROR | 62,
+    GPG_ERR_ELOOP = GPG_ERR_SYSTEM_ERROR | 63,
+    GPG_ERR_EMEDIUMTYPE = GPG_ERR_SYSTEM_ERROR | 64,
+    GPG_ERR_EMFILE = GPG_ERR_SYSTEM_ERROR | 65,
+    GPG_ERR_EMLINK = GPG_ERR_SYSTEM_ERROR | 66,
+    GPG_ERR_EMSGSIZE = GPG_ERR_SYSTEM_ERROR | 67,
+    GPG_ERR_EMULTIHOP = GPG_ERR_SYSTEM_ERROR | 68,
+    GPG_ERR_ENAMETOOLONG = GPG_ERR_SYSTEM_ERROR | 69,
+    GPG_ERR_ENAVAIL = GPG_ERR_SYSTEM_ERROR | 70,
+    GPG_ERR_ENEEDAUTH = GPG_ERR_SYSTEM_ERROR | 71,
+    GPG_ERR_ENETDOWN = GPG_ERR_SYSTEM_ERROR | 72,
+    GPG_ERR_ENETRESET = GPG_ERR_SYSTEM_ERROR | 73,
+    GPG_ERR_ENETUNREACH = GPG_ERR_SYSTEM_ERROR | 74,
+    GPG_ERR_ENFILE = GPG_ERR_SYSTEM_ERROR | 75,
+    GPG_ERR_ENOANO = GPG_ERR_SYSTEM_ERROR | 76,
+    GPG_ERR_ENOBUFS = GPG_ERR_SYSTEM_ERROR | 77,
+    GPG_ERR_ENOCSI = GPG_ERR_SYSTEM_ERROR | 78,
+    GPG_ERR_ENODATA = GPG_ERR_SYSTEM_ERROR | 79,
+    GPG_ERR_ENODEV = GPG_ERR_SYSTEM_ERROR | 80,
+    GPG_ERR_ENOENT = GPG_ERR_SYSTEM_ERROR | 81,
+    GPG_ERR_ENOEXEC = GPG_ERR_SYSTEM_ERROR | 82,
+    GPG_ERR_ENOLCK = GPG_ERR_SYSTEM_ERROR | 83,
+    GPG_ERR_ENOLINK = GPG_ERR_SYSTEM_ERROR | 84,
+    GPG_ERR_ENOMEDIUM = GPG_ERR_SYSTEM_ERROR | 85,
+    GPG_ERR_ENOMEM = GPG_ERR_SYSTEM_ERROR | 86,
+    GPG_ERR_ENOMSG = GPG_ERR_SYSTEM_ERROR | 87,
+    GPG_ERR_ENONET = GPG_ERR_SYSTEM_ERROR | 88,
+    GPG_ERR_ENOPKG = GPG_ERR_SYSTEM_ERROR | 89,
+    GPG_ERR_ENOPROTOOPT = GPG_ERR_SYSTEM_ERROR | 90,
+    GPG_ERR_ENOSPC = GPG_ERR_SYSTEM_ERROR | 91,
+    GPG_ERR_ENOSR = GPG_ERR_SYSTEM_ERROR | 92,
+    GPG_ERR_ENOSTR = GPG_ERR_SYSTEM_ERROR | 93,
+    GPG_ERR_ENOSYS = GPG_ERR_SYSTEM_ERROR | 94,
+    GPG_ERR_ENOTBLK = GPG_ERR_SYSTEM_ERROR | 95,
+    GPG_ERR_ENOTCONN = GPG_ERR_SYSTEM_ERROR | 96,
+    GPG_ERR_ENOTDIR = GPG_ERR_SYSTEM_ERROR | 97,
+    GPG_ERR_ENOTEMPTY = GPG_ERR_SYSTEM_ERROR | 98,
+    GPG_ERR_ENOTNAM = GPG_ERR_SYSTEM_ERROR | 99,
+    GPG_ERR_ENOTSOCK = GPG_ERR_SYSTEM_ERROR | 100,
+    GPG_ERR_ENOTSUP = GPG_ERR_SYSTEM_ERROR | 101,
+    GPG_ERR_ENOTTY = GPG_ERR_SYSTEM_ERROR | 102,
+    GPG_ERR_ENOTUNIQ = GPG_ERR_SYSTEM_ERROR | 103,
+    GPG_ERR_ENXIO = GPG_ERR_SYSTEM_ERROR | 104,
+    GPG_ERR_EOPNOTSUPP = GPG_ERR_SYSTEM_ERROR | 105,
+    GPG_ERR_EOVERFLOW = GPG_ERR_SYSTEM_ERROR | 106,
+    GPG_ERR_EPERM = GPG_ERR_SYSTEM_ERROR | 107,
+    GPG_ERR_EPFNOSUPPORT = GPG_ERR_SYSTEM_ERROR | 108,
+    GPG_ERR_EPIPE = GPG_ERR_SYSTEM_ERROR | 109,
+    GPG_ERR_EPROCLIM = GPG_ERR_SYSTEM_ERROR | 110,
+    GPG_ERR_EPROCUNAVAIL = GPG_ERR_SYSTEM_ERROR | 111,
+    GPG_ERR_EPROGMISMATCH = GPG_ERR_SYSTEM_ERROR | 112,
+    GPG_ERR_EPROGUNAVAIL = GPG_ERR_SYSTEM_ERROR | 113,
+    GPG_ERR_EPROTO = GPG_ERR_SYSTEM_ERROR | 114,
+    GPG_ERR_EPROTONOSUPPORT = GPG_ERR_SYSTEM_ERROR | 115,
+    GPG_ERR_EPROTOTYPE = GPG_ERR_SYSTEM_ERROR | 116,
+    GPG_ERR_ERANGE = GPG_ERR_SYSTEM_ERROR | 117,
+    GPG_ERR_EREMCHG = GPG_ERR_SYSTEM_ERROR | 118,
+    GPG_ERR_EREMOTE = GPG_ERR_SYSTEM_ERROR | 119,
+    GPG_ERR_EREMOTEIO = GPG_ERR_SYSTEM_ERROR | 120,
+    GPG_ERR_ERESTART = GPG_ERR_SYSTEM_ERROR | 121,
+    GPG_ERR_EROFS = GPG_ERR_SYSTEM_ERROR | 122,
+    GPG_ERR_ERPCMISMATCH = GPG_ERR_SYSTEM_ERROR | 123,
+    GPG_ERR_ESHUTDOWN = GPG_ERR_SYSTEM_ERROR | 124,
+    GPG_ERR_ESOCKTNOSUPPORT = GPG_ERR_SYSTEM_ERROR | 125,
+    GPG_ERR_ESPIPE = GPG_ERR_SYSTEM_ERROR | 126,
+    GPG_ERR_ESRCH = GPG_ERR_SYSTEM_ERROR | 127,
+    GPG_ERR_ESRMNT = GPG_ERR_SYSTEM_ERROR | 128,
+    GPG_ERR_ESTALE = GPG_ERR_SYSTEM_ERROR | 129,
+    GPG_ERR_ESTRPIPE = GPG_ERR_SYSTEM_ERROR | 130,
+    GPG_ERR_ETIME = GPG_ERR_SYSTEM_ERROR | 131,
+    GPG_ERR_ETIMEDOUT = GPG_ERR_SYSTEM_ERROR | 132,
+    GPG_ERR_ETOOMANYREFS = GPG_ERR_SYSTEM_ERROR | 133,
+    GPG_ERR_ETXTBSY = GPG_ERR_SYSTEM_ERROR | 134,
+    GPG_ERR_EUCLEAN = GPG_ERR_SYSTEM_ERROR | 135,
+    GPG_ERR_EUNATCH = GPG_ERR_SYSTEM_ERROR | 136,
+    GPG_ERR_EUSERS = GPG_ERR_SYSTEM_ERROR | 137,
+    GPG_ERR_EWOULDBLOCK = GPG_ERR_SYSTEM_ERROR | 138,
+    GPG_ERR_EXDEV = GPG_ERR_SYSTEM_ERROR | 139,
+    GPG_ERR_EXFULL = GPG_ERR_SYSTEM_ERROR | 140,
+
+    /* This is one more than the largest allowed entry.  */
+    GPG_ERR_CODE_DIM = 65536
+  } gpg_err_code_t;
+
+
+/* The error value type gpg_error_t.  */
+
+/* We would really like to use bit-fields in a struct, but using
+ * structs as return values can cause binary compatibility issues, in
+ * particular if you want to do it efficiently (also see
+ * -freg-struct-return option to GCC).  */
+typedef unsigned int gpg_error_t;
+
+/* We use the lowest 16 bits of gpg_error_t for error codes.  The 16th
+ * bit indicates system errors.  */
+#define GPG_ERR_CODE_MASK	(GPG_ERR_CODE_DIM - 1)
+
+/* Bits 17 to 24 are reserved.  */
+
+/* We use the upper 7 bits of gpg_error_t for error sources.  */
+#define GPG_ERR_SOURCE_MASK	(GPG_ERR_SOURCE_DIM - 1)
+#define GPG_ERR_SOURCE_SHIFT	24
+
+/* The highest bit is reserved.  It shouldn't be used to prevent
+ * potential negative numbers when transmitting error values as
+ * text.  */
+
+
+/*
+ * GCC feature test.
+ */
+#if __GNUC__
+# define _GPG_ERR_GCC_VERSION (__GNUC__ * 10000 \
+                               + __GNUC_MINOR__ * 100 \
+                               + __GNUC_PATCHLEVEL__)
+#else
+# define _GPG_ERR_GCC_VERSION 0
+#endif
+
+#undef _GPG_ERR_HAVE_CONSTRUCTOR
+#if _GPG_ERR_GCC_VERSION > 30100
+# define _GPG_ERR_CONSTRUCTOR	__attribute__ ((__constructor__))
+# define _GPG_ERR_HAVE_CONSTRUCTOR
+#else
+# define _GPG_ERR_CONSTRUCTOR
+#endif
+
+#define GPGRT_GCC_VERSION  _GPG_ERR_GCC_VERSION
+
+#if _GPG_ERR_GCC_VERSION >= 29200
+# define _GPGRT__RESTRICT __restrict__
+#else
+# define _GPGRT__RESTRICT
+#endif
+
+/* The noreturn attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 20500
+# define GPGRT_ATTR_NORETURN   __attribute__ ((__noreturn__))
+#else
+# define GPGRT_ATTR_NORETURN
+#endif
+
+/* The printf attributes.  */
+#if _GPG_ERR_GCC_VERSION >= 40400
+# define GPGRT_ATTR_PRINTF(f, a) \
+                    __attribute__ ((format(__gnu_printf__,f,a)))
+# define GPGRT_ATTR_NR_PRINTF(f, a) \
+                    __attribute__ ((__noreturn__, format(__gnu_printf__,f,a)))
+#elif _GPG_ERR_GCC_VERSION >= 20500
+# define GPGRT_ATTR_PRINTF(f, a) \
+                    __attribute__ ((format(printf,f,a)))
+# define GPGRT_ATTR_NR_PRINTF(f, a) \
+                    __attribute__ ((__noreturn__, format(printf,f,a)))
+#else
+# define GPGRT_ATTR_PRINTF(f, a)
+# define GPGRT_ATTR_NR_PRINTF(f, a)
+#endif
+#if _GPG_ERR_GCC_VERSION >= 20800
+# define GPGRT_ATTR_FORMAT_ARG(a)  __attribute__ ((__format_arg__ (a)))
+#else
+# define GPGRT_ATTR_FORMAT_ARG(a)
+#endif
+
+/* The sentinel attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 40000
+# define GPGRT_ATTR_SENTINEL(a)  __attribute__ ((sentinel(a)))
+#else
+# define GPGRT_ATTR_SENTINEL(a)
+#endif
+
+/* The used and unused attributes.
+ * I am not sure since when the unused attribute is really supported.
+ * In any case it it only needed for gcc versions which print a
+ * warning.  Thus let us require gcc >= 3.5.  */
+#if _GPG_ERR_GCC_VERSION >= 40000
+# define GPGRT_ATTR_USED  __attribute__ ((used))
+#else
+# define GPGRT_ATTR_USED
+#endif
+#if _GPG_ERR_GCC_VERSION >= 30500
+# define GPGRT_ATTR_UNUSED  __attribute__ ((unused))
+#else
+# define GPGRT_ATTR_UNUSED
+#endif
+
+/* The deprecated attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 30100
+# define GPGRT_ATTR_DEPRECATED  __attribute__ ((__deprecated__))
+#else
+# define GPGRT_ATTR_DEPRECATED
+#endif
+
+/* The pure attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 29600
+# define GPGRT_ATTR_PURE  __attribute__ ((__pure__))
+#else
+# define GPGRT_ATTR_PURE
+#endif
+
+/* The malloc attribute.  */
+#if _GPG_ERR_GCC_VERSION >= 30200
+# define GPGRT_ATTR_MALLOC  __attribute__ ((__malloc__))
+#else
+# define GPGRT_ATTR_MALLOC
+#endif
+
+/* A macro defined if a GCC style __FUNCTION__ macro is available.  */
+# define GPGRT_HAVE_MACRO_FUNCTION 1
+
+/* A macro defined if the pragma GCC push_options is available.  */
+#undef GPGRT_HAVE_PRAGMA_GCC_PUSH
+#if _GPG_ERR_GCC_VERSION >= 40400
+# define GPGRT_HAVE_PRAGMA_GCC_PUSH 1
+#endif
+
+/* Detect LeakSanitizer (LSan) support for GCC and Clang based on
+ * whether AddressSanitizer (ASAN) is enabled via -fsanitize=address).
+ * Note that -fsanitize=leak just affect the linker options which
+ * cannot be detected here.  In that case you have to define the
+ * GPGRT_HAVE_LEAK_SANITIZER macro manually.  */
+#ifdef __GNUC__
+# ifdef __SANITIZE_ADDRESS__
+#  define GPGRT_HAVE_LEAK_SANITIZER
+# elif defined(__has_feature)
+#  if __has_feature(address_sanitizer)
+#   define GPGRT_HAVE_LEAK_SANITIZER
+#  endif
+# endif
+#endif
+
+
+/* The new name for the inline macro.  */
+#define GPGRT_INLINE GPG_ERR_INLINE
+
+#ifdef GPGRT_HAVE_LEAK_SANITIZER
+# include <sanitizer/lsan_interface.h>
+#endif
+
+/* Mark heap objects as non-leaked memory. */
+static GPGRT_INLINE void
+gpgrt_annotate_leaked_object (const void *p)
+{
+#ifdef GPGRT_HAVE_LEAK_SANITIZER
+  __lsan_ignore_object(p);
+#else
+  (void)p;
+#endif
+}
+
+
+/*
+ * Initialization function.
+ */
+
+/* Initialize the library.  This function should be run early.  */
+gpg_error_t gpg_err_init (void) _GPG_ERR_CONSTRUCTOR;
+
+/* If this is defined, the library is already initialized by the
+   constructor and does not need to be initialized explicitely.  */
+#undef GPG_ERR_INITIALIZED
+#ifdef _GPG_ERR_HAVE_CONSTRUCTOR
+# define GPG_ERR_INITIALIZED	1
+# define gpgrt_init() do { gpg_err_init (); } while (0)
+#else
+# define gpgrt_init() do { ; } while (0)
+#endif
+
+/* See the source on how to use the deinit function; it is usually not
+   required.  */
+void gpg_err_deinit (int mode);
+
+/* Register blocking system I/O clamping functions.  */
+void gpgrt_set_syscall_clamp (void (*pre)(void), void (*post)(void));
+
+/* Get current I/O clamping functions.  */
+void gpgrt_get_syscall_clamp (void (**r_pre)(void), void (**r_post)(void));
+
+/* Register a custom malloc/realloc/free function.  */
+void gpgrt_set_alloc_func  (void *(*f)(void *a, size_t n));
+
+/* Register an emergency cleanup handler.  */
+void gpgrt_add_emergency_cleanup (void (*f)(void));
+
+/* Wrapper around abort to make sure emergency cleanups are run.  */
+void gpgrt_abort (void) GPGRT_ATTR_NORETURN;
+
+
+
+/*
+ * Constructor and accessor functions.
+ */
+
+/* Construct an error value from an error code and source.  Within a
+ * subsystem, use gpg_error.  */
+static GPG_ERR_INLINE gpg_error_t
+gpg_err_make (gpg_err_source_t source, gpg_err_code_t code)
+{
+  return code == GPG_ERR_NO_ERROR ? GPG_ERR_NO_ERROR
+    : (((source & GPG_ERR_SOURCE_MASK) << GPG_ERR_SOURCE_SHIFT)
+       | (code & GPG_ERR_CODE_MASK));
+}
+
+
+/* The user should define GPG_ERR_SOURCE_DEFAULT before including this
+ * file to specify a default source for gpg_error.  */
+#ifndef GPG_ERR_SOURCE_DEFAULT
+#define GPG_ERR_SOURCE_DEFAULT	GPG_ERR_SOURCE_UNKNOWN
+#endif
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_error (gpg_err_code_t code)
+{
+  return gpg_err_make (GPG_ERR_SOURCE_DEFAULT, code);
+}
+
+
+/* Retrieve the error code from an error value.  */
+static GPG_ERR_INLINE gpg_err_code_t
+gpg_err_code (gpg_error_t err)
+{
+  return (gpg_err_code_t) (err & GPG_ERR_CODE_MASK);
+}
+
+
+/* Retrieve the error source from an error value.  */
+static GPG_ERR_INLINE gpg_err_source_t
+gpg_err_source (gpg_error_t err)
+{
+  return (gpg_err_source_t) ((err >> GPG_ERR_SOURCE_SHIFT)
+			     & GPG_ERR_SOURCE_MASK);
+}
+
+
+/* String functions.  */
+
+/* Return a pointer to a string containing a description of the error
+ * code in the error value ERR.  This function is not thread-safe.  */
+const char *gpg_strerror (gpg_error_t err);
+
+/* Return the error string for ERR in the user-supplied buffer BUF of
+ * size BUFLEN.  This function is, in contrast to gpg_strerror,
+ * thread-safe if a thread-safe strerror_r() function is provided by
+ * the system.  If the function succeeds, 0 is returned and BUF
+ * contains the string describing the error.  If the buffer was not
+ * large enough, ERANGE is returned and BUF contains as much of the
+ * beginning of the error string as fits into the buffer.  */
+int gpg_strerror_r (gpg_error_t err, char *buf, size_t buflen);
+
+/* Return a pointer to a string containing a description of the error
+ * source in the error value ERR.  */
+const char *gpg_strsource (gpg_error_t err);
+
+
+/*
+ * Mapping of system errors (errno).
+ */
+
+/* Retrieve the error code for the system error ERR.  This returns
+ * GPG_ERR_UNKNOWN_ERRNO if the system error is not mapped (report
+ * this). */
+gpg_err_code_t gpg_err_code_from_errno (int err);
+
+/* Retrieve the system error for the error code CODE.  This returns 0
+ * if CODE is not a system error code.  */
+int gpg_err_code_to_errno (gpg_err_code_t code);
+
+/* Retrieve the error code directly from the ERRNO variable.  This
+ * returns GPG_ERR_UNKNOWN_ERRNO if the system error is not mapped
+ * (report this) and GPG_ERR_MISSING_ERRNO if ERRNO has the value 0. */
+gpg_err_code_t gpg_err_code_from_syserror (void);
+
+
+/* Set the ERRNO variable.  This function is the preferred way to set
+ * ERRNO due to peculiarities on WindowsCE.  */
+void gpg_err_set_errno (int err);
+
+/* Return or check the version.  Both functions are identical.  */
+const char *gpgrt_check_version (const char *req_version);
+const char *gpg_error_check_version (const char *req_version);
+
+/* System specific type definitions.  */
+#include <sys/types.h>
+
+typedef __int64 ssize_t;
+typedef ssize_t gpgrt_ssize_t;
+
+typedef long gpgrt_off_t;
+
+
+
+
+/* Self-documenting convenience functions.  */
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_err_make_from_errno (gpg_err_source_t source, int err)
+{
+  return gpg_err_make (source, gpg_err_code_from_errno (err));
+}
+
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_error_from_errno (int err)
+{
+  return gpg_error (gpg_err_code_from_errno (err));
+}
+
+static GPG_ERR_INLINE gpg_error_t
+gpg_error_from_syserror (void)
+{
+  return gpg_error (gpg_err_code_from_syserror ());
+}
+
+
+
+/*
+ * Malloc and friends
+ */
+
+void *gpgrt_realloc (void *a, size_t n);
+void *gpgrt_malloc (size_t n);
+void *gpgrt_calloc (size_t n, size_t m);
+char *gpgrt_strdup (const char *string);
+char *gpgrt_strconcat (const char *s1, ...) GPGRT_ATTR_SENTINEL(0);
+void gpgrt_free (void *a);
+
+
+/*
+ * System specific function wrappers.
+ */
+
+/* A getenv replacement which mallocs the returned string.  */
+char *gpgrt_getenv (const char *name);
+
+/* A setenv and a unsetenv replacement.*/
+gpg_err_code_t gpgrt_setenv (const char *name,
+                             const char *value, int overwrite);
+#define gpgrt_unsetenv(n) gpgrt_setenv ((n), NULL, 1)
+
+/* A wrapper around mkdir using a string for the mode.  */
+gpg_err_code_t gpgrt_mkdir (const char *name, const char *modestr);
+
+/* A simple wrapper around chdir.  */
+gpg_err_code_t gpgrt_chdir (const char *name);
+
+/* Return the current WD as a malloced string.  */
+char *gpgrt_getcwd (void);
+
+
+
+
+/*
+ * Lock functions.
+ */
+
+
+typedef struct
+{
+  long _vers;
+  union {
+    volatile char _priv[40];
+    long _x_align;
+    long *_xp_align;
+  } u;
+} gpgrt_lock_t;
+
+#define GPGRT_LOCK_INITIALIZER {1,{{0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0, \
+                                    0,0,0,0,0,0,0,0}}}
+
+
+#define GPGRT_LOCK_DEFINE(name) \
+  static gpgrt_lock_t name  = GPGRT_LOCK_INITIALIZER
+
+/* NB: If GPGRT_LOCK_DEFINE is not used, zero out the lock variable
+   before passing it to gpgrt_lock_init.  */
+gpg_err_code_t gpgrt_lock_init (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_lock (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_trylock (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_unlock (gpgrt_lock_t *lockhd);
+gpg_err_code_t gpgrt_lock_destroy (gpgrt_lock_t *lockhd);
+
+
+
+/*
+ * Thread functions.
+ */
+
+gpg_err_code_t gpgrt_yield (void);
+
+
+
+
+/*
+ * Estream
+ */
+
+/* The definition of this struct is entirely private.  You must not
+   use it for anything.  It is only here so some functions can be
+   implemented as macros.  */
+struct _gpgrt_stream_internal;
+struct _gpgrt__stream
+{
+  /* The layout of this struct must never change.  It may be grown,
+     but only if all functions which access the new members are
+     versioned.  */
+
+  /* Various flags.  */
+  struct {
+    unsigned int magic: 16;
+    unsigned int writing: 1;
+    unsigned int reserved: 15;
+  } flags;
+
+  /* A pointer to the stream buffer.  */
+  unsigned char *buffer;
+
+  /* The size of the buffer in bytes.  */
+  size_t buffer_size;
+
+  /* The length of the usable data in the buffer, only valid when in
+     read mode (see flags).  */
+  size_t data_len;
+
+  /* The current position of the offset pointer, valid in read and
+     write mode.  */
+  size_t data_offset;
+
+  size_t data_flushed;
+  unsigned char *unread_buffer;
+  size_t unread_buffer_size;
+
+  /* The number of unread bytes.  */
+  size_t unread_data_len;
+
+  /* A pointer to our internal data for this stream.  */
+  struct _gpgrt_stream_internal *intern;
+};
+
+/* The opaque type for an estream.  */
+typedef struct _gpgrt__stream *gpgrt_stream_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt__stream *estream_t;
+#endif
+
+typedef ssize_t (*gpgrt_cookie_read_function_t) (void *cookie,
+                                                 void *buffer, size_t size);
+typedef ssize_t (*gpgrt_cookie_write_function_t) (void *cookie,
+                                                  const void *buffer,
+                                                  size_t size);
+typedef int (*gpgrt_cookie_seek_function_t) (void *cookie,
+                                             gpgrt_off_t *pos, int whence);
+typedef int (*gpgrt_cookie_close_function_t) (void *cookie);
+
+struct _gpgrt_cookie_io_functions
+{
+  gpgrt_cookie_read_function_t func_read;
+  gpgrt_cookie_write_function_t func_write;
+  gpgrt_cookie_seek_function_t func_seek;
+  gpgrt_cookie_close_function_t func_close;
+};
+typedef struct _gpgrt_cookie_io_functions gpgrt_cookie_io_functions_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt_cookie_io_functions  es_cookie_io_functions_t;
+#define es_cookie_read_function_t  gpgrt_cookie_read_function_t
+#define es_cookie_write_function_t gpgrt_cookie_read_function_t
+#define es_cookie_seek_function_t  gpgrt_cookie_read_function_t
+#define es_cookie_close_function_t gpgrt_cookie_read_function_t
+#endif
+
+enum gpgrt_syshd_types
+  {
+    GPGRT_SYSHD_NONE = 0,  /* No system handle available.                   */
+    GPGRT_SYSHD_FD = 1,    /* A file descriptor as returned by open().      */
+    GPGRT_SYSHD_SOCK = 2,  /* A socket as returned by socket().             */
+    GPGRT_SYSHD_RVID = 3,  /* A rendezvous id (see libassuan's gpgcedev.c).  */
+    GPGRT_SYSHD_HANDLE = 4 /* A HANDLE object (Windows).                    */
+  };
+
+struct _gpgrt_syshd
+{
+  enum gpgrt_syshd_types type;
+  union {
+    int fd;
+    int sock;
+    int rvid;
+    void *handle;
+  } u;
+};
+typedef struct _gpgrt_syshd gpgrt_syshd_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt_syshd es_syshd_t;
+#define ES_SYSHD_NONE   GPGRT_SYSHD_NONE
+#define ES_SYSHD_FD     GPGRT_SYSHD_FD
+#define ES_SYSHD_SOCK   GPGRT_SYSHD_SOCK
+#define ES_SYSHD_RVID   GPGRT_SYSHD_RVID
+#define ES_SYSHD_HANDLE GPGRT_SYSHD_HANDLE
+#endif
+
+/* The object used with gpgrt_poll.  */
+struct _gpgrt_poll_s
+{
+  gpgrt_stream_t stream;
+  unsigned int want_read:1;
+  unsigned int want_write:1;
+  unsigned int want_oob:1;
+  unsigned int want_rdhup:1;
+  unsigned int _reserv1:4;
+  unsigned int got_read:1;
+  unsigned int got_write:1;
+  unsigned int got_oob:1;
+  unsigned int got_rdhup:1;
+  unsigned int _reserv2:4;
+  unsigned int got_err:1;
+  unsigned int got_hup:1;
+  unsigned int got_nval:1;
+  unsigned int _reserv3:4;
+  unsigned int ignore:1;
+  unsigned int user:8;       /* For application use.  */
+};
+typedef struct _gpgrt_poll_s gpgrt_poll_t;
+#ifdef GPGRT_ENABLE_ES_MACROS
+typedef struct _gpgrt_poll_s es_poll_t;
+#endif
+
+/* The type of the string filter function as used by fprintf_sf et al.  */
+typedef char *(*gpgrt_string_filter_t) (const char *s, int n, void *opaque);
+
+
+
+gpgrt_stream_t gpgrt_fopen (const char *_GPGRT__RESTRICT path,
+                            const char *_GPGRT__RESTRICT mode);
+gpgrt_stream_t gpgrt_mopen (void *_GPGRT__RESTRICT data,
+                            size_t data_n, size_t data_len,
+                            unsigned int grow,
+                            void *(*func_realloc) (void *mem, size_t size),
+                            void (*func_free) (void *mem),
+                            const char *_GPGRT__RESTRICT mode);
+gpgrt_stream_t gpgrt_fopenmem (size_t memlimit,
+                               const char *_GPGRT__RESTRICT mode);
+gpgrt_stream_t gpgrt_fopenmem_init (size_t memlimit,
+                                    const char *_GPGRT__RESTRICT mode,
+                                    const void *data, size_t datalen);
+gpgrt_stream_t gpgrt_fdopen    (int filedes, const char *mode);
+gpgrt_stream_t gpgrt_fdopen_nc (int filedes, const char *mode);
+gpgrt_stream_t gpgrt_sysopen    (gpgrt_syshd_t *syshd, const char *mode);
+gpgrt_stream_t gpgrt_sysopen_nc (gpgrt_syshd_t *syshd, const char *mode);
+gpgrt_stream_t gpgrt_fpopen    (FILE *fp, const char *mode);
+gpgrt_stream_t gpgrt_fpopen_nc (FILE *fp, const char *mode);
+gpgrt_stream_t gpgrt_freopen (const char *_GPGRT__RESTRICT path,
+                              const char *_GPGRT__RESTRICT mode,
+                              gpgrt_stream_t _GPGRT__RESTRICT stream);
+gpgrt_stream_t gpgrt_fopencookie (void *_GPGRT__RESTRICT cookie,
+                                  const char *_GPGRT__RESTRICT mode,
+                                  gpgrt_cookie_io_functions_t functions);
+int gpgrt_fclose (gpgrt_stream_t stream);
+int gpgrt_fclose_snatch (gpgrt_stream_t stream,
+                         void **r_buffer, size_t *r_buflen);
+int gpgrt_onclose (gpgrt_stream_t stream, int mode,
+                   void (*fnc) (gpgrt_stream_t, void*), void *fnc_value);
+int gpgrt_fileno (gpgrt_stream_t stream);
+int gpgrt_fileno_unlocked (gpgrt_stream_t stream);
+int gpgrt_syshd (gpgrt_stream_t stream, gpgrt_syshd_t *syshd);
+int gpgrt_syshd_unlocked (gpgrt_stream_t stream, gpgrt_syshd_t *syshd);
+
+void _gpgrt_set_std_fd (int no, int fd);
+gpgrt_stream_t _gpgrt_get_std_stream (int fd);
+
+#define gpgrt_stdin  _gpgrt_get_std_stream (0)
+#define gpgrt_stdout _gpgrt_get_std_stream (1)
+#define gpgrt_stderr _gpgrt_get_std_stream (2)
+
+
+void gpgrt_flockfile (gpgrt_stream_t stream);
+int  gpgrt_ftrylockfile (gpgrt_stream_t stream);
+void gpgrt_funlockfile (gpgrt_stream_t stream);
+
+int gpgrt_feof (gpgrt_stream_t stream);
+int gpgrt_feof_unlocked (gpgrt_stream_t stream);
+int gpgrt_ferror (gpgrt_stream_t stream);
+int gpgrt_ferror_unlocked (gpgrt_stream_t stream);
+void gpgrt_clearerr (gpgrt_stream_t stream);
+void gpgrt_clearerr_unlocked (gpgrt_stream_t stream);
+
+int _gpgrt_pending (gpgrt_stream_t stream);          /* (private) */
+int _gpgrt_pending_unlocked (gpgrt_stream_t stream); /* (private) */
+
+#define gpgrt_pending(stream) _gpgrt_pending (stream)
+
+#define gpgrt_pending_unlocked(stream)				\
+  (((!(stream)->flags.writing)					\
+    && (((stream)->data_offset < (stream)->data_len)		\
+        || ((stream)->unread_data_len)))                        \
+   ? 1 : _gpgrt_pending_unlocked ((stream)))
+
+int gpgrt_fflush (gpgrt_stream_t stream);
+int gpgrt_fseek (gpgrt_stream_t stream, long int offset, int whence);
+int gpgrt_fseeko (gpgrt_stream_t stream, gpgrt_off_t offset, int whence);
+int gpgrt_ftruncate (gpgrt_stream_t stream, gpgrt_off_t length);
+long int gpgrt_ftell (gpgrt_stream_t stream);
+gpgrt_off_t gpgrt_ftello (gpgrt_stream_t stream);
+void gpgrt_rewind (gpgrt_stream_t stream);
+
+int gpgrt_fgetc (gpgrt_stream_t stream);
+int gpgrt_fputc (int c, gpgrt_stream_t stream);
+
+int _gpgrt_getc_underflow (gpgrt_stream_t stream);       /* (private) */
+int _gpgrt_putc_overflow (int c, gpgrt_stream_t stream); /* (private) */
+
+#define gpgrt_getc_unlocked(stream)				\
+  (((!(stream)->flags.writing)					\
+    && ((stream)->data_offset < (stream)->data_len)		\
+    && (! (stream)->unread_data_len))				\
+  ? ((int) (stream)->buffer[((stream)->data_offset)++])		\
+  : _gpgrt_getc_underflow ((stream)))
+
+#define gpgrt_putc_unlocked(c, stream)				\
+  (((stream)->flags.writing					\
+    && ((stream)->data_offset < (stream)->buffer_size)		\
+    && (c != '\n'))						\
+  ? ((int) ((stream)->buffer[((stream)->data_offset)++] = (c)))	\
+  : _gpgrt_putc_overflow ((c), (stream)))
+
+#define gpgrt_getc(stream)    gpgrt_fgetc (stream)
+#define gpgrt_putc(c, stream) gpgrt_fputc (c, stream)
+
+int gpgrt_ungetc (int c, gpgrt_stream_t stream);
+
+int gpgrt_read (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                void *_GPGRT__RESTRICT buffer, size_t bytes_to_read,
+                size_t *_GPGRT__RESTRICT bytes_read);
+int gpgrt_write (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                 const void *_GPGRT__RESTRICT buffer, size_t bytes_to_write,
+                 size_t *_GPGRT__RESTRICT bytes_written);
+int gpgrt_write_sanitized (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                           const void *_GPGRT__RESTRICT buffer, size_t length,
+                           const char *delimiters,
+                           size_t *_GPGRT__RESTRICT bytes_written);
+int gpgrt_write_hexstring (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                           const void *_GPGRT__RESTRICT buffer, size_t length,
+                           int reserved,
+                           size_t *_GPGRT__RESTRICT bytes_written);
+
+size_t gpgrt_fread (void *_GPGRT__RESTRICT ptr, size_t size, size_t nitems,
+                    gpgrt_stream_t _GPGRT__RESTRICT stream);
+size_t gpgrt_fwrite (const void *_GPGRT__RESTRICT ptr, size_t size,
+                     size_t nitems, gpgrt_stream_t _GPGRT__RESTRICT stream);
+
+char *gpgrt_fgets (char *_GPGRT__RESTRICT s, int n,
+                   gpgrt_stream_t _GPGRT__RESTRICT stream);
+int gpgrt_fputs (const char *_GPGRT__RESTRICT s,
+                 gpgrt_stream_t _GPGRT__RESTRICT stream);
+int gpgrt_fputs_unlocked (const char *_GPGRT__RESTRICT s,
+                          gpgrt_stream_t _GPGRT__RESTRICT stream);
+
+ssize_t gpgrt_getline (char *_GPGRT__RESTRICT *_GPGRT__RESTRICT lineptr,
+                       size_t *_GPGRT__RESTRICT n,
+                       gpgrt_stream_t stream);
+ssize_t gpgrt_read_line (gpgrt_stream_t stream,
+                         char **addr_of_buffer, size_t *length_of_buffer,
+                         size_t *max_length);
+
+int gpgrt_fprintf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                   const char *_GPGRT__RESTRICT format, ...)
+                   GPGRT_ATTR_PRINTF(2,3);
+int gpgrt_fprintf_unlocked (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                            const char *_GPGRT__RESTRICT format, ...)
+                            GPGRT_ATTR_PRINTF(2,3);
+
+int gpgrt_fprintf_sf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                      gpgrt_string_filter_t sf, void *sfvalue,
+                      const char *_GPGRT__RESTRICT format,
+                      ...) GPGRT_ATTR_PRINTF(4,5);
+int gpgrt_fprintf_sf_unlocked (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                               gpgrt_string_filter_t sf, void *sfvalue,
+                               const char *_GPGRT__RESTRICT format,
+                               ...) GPGRT_ATTR_PRINTF(4,5);
+
+int gpgrt_printf (const char *_GPGRT__RESTRICT format, ...)
+                  GPGRT_ATTR_PRINTF(1,2);
+int gpgrt_printf_unlocked (const char *_GPGRT__RESTRICT format, ...)
+                           GPGRT_ATTR_PRINTF(1,2);
+
+int gpgrt_vfprintf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                    const char *_GPGRT__RESTRICT format, va_list ap)
+                    GPGRT_ATTR_PRINTF(2,0);
+int gpgrt_vfprintf_unlocked (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                             const char *_GPGRT__RESTRICT format, va_list ap)
+                             GPGRT_ATTR_PRINTF(2,0);
+
+int gpgrt_setvbuf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                   char *_GPGRT__RESTRICT buf, int mode, size_t size);
+void gpgrt_setbuf (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                   char *_GPGRT__RESTRICT buf);
+
+void gpgrt_set_binary (gpgrt_stream_t stream);
+int  gpgrt_set_nonblock (gpgrt_stream_t stream, int onoff);
+int  gpgrt_get_nonblock (gpgrt_stream_t stream);
+
+int gpgrt_poll (gpgrt_poll_t *fdlist, unsigned int nfds, int timeout);
+
+gpgrt_stream_t gpgrt_tmpfile (void);
+
+void gpgrt_opaque_set (gpgrt_stream_t _GPGRT__RESTRICT stream,
+                       void *_GPGRT__RESTRICT opaque);
+void *gpgrt_opaque_get (gpgrt_stream_t stream);
+
+void gpgrt_fname_set (gpgrt_stream_t stream, const char *fname);
+const char *gpgrt_fname_get (gpgrt_stream_t stream);
+
+int gpgrt_asprintf (char **r_buf, const char * _GPGRT__RESTRICT format, ...)
+                    GPGRT_ATTR_PRINTF(2,3);
+int gpgrt_vasprintf (char **r_buf, const char * _GPGRT__RESTRICT format,
+                     va_list ap)
+                     GPGRT_ATTR_PRINTF(2,0);
+char *gpgrt_bsprintf (const char * _GPGRT__RESTRICT format, ...)
+                      GPGRT_ATTR_PRINTF(1,2);
+char *gpgrt_vbsprintf (const char * _GPGRT__RESTRICT format, va_list ap)
+                       GPGRT_ATTR_PRINTF(1,0);
+int gpgrt_snprintf (char *buf, size_t bufsize,
+                    const char * _GPGRT__RESTRICT format, ...)
+                    GPGRT_ATTR_PRINTF(3,4);
+int gpgrt_vsnprintf (char *buf,size_t bufsize,
+                     const char * _GPGRT__RESTRICT format, va_list arg_ptr)
+                     GPGRT_ATTR_PRINTF(3,0);
+
+
+#ifdef GPGRT_ENABLE_ES_MACROS
+# define es_fopen             gpgrt_fopen
+# define es_mopen             gpgrt_mopen
+# define es_fopenmem          gpgrt_fopenmem
+# define es_fopenmem_init     gpgrt_fopenmem_init
+# define es_fdopen            gpgrt_fdopen
+# define es_fdopen_nc         gpgrt_fdopen_nc
+# define es_sysopen           gpgrt_sysopen
+# define es_sysopen_nc        gpgrt_sysopen_nc
+# define es_fpopen            gpgrt_fpopen
+# define es_fpopen_nc         gpgrt_fpopen_nc
+# define es_freopen           gpgrt_freopen
+# define es_fopencookie       gpgrt_fopencookie
+# define es_fclose            gpgrt_fclose
+# define es_fclose_snatch     gpgrt_fclose_snatch
+# define es_onclose           gpgrt_onclose
+# define es_fileno            gpgrt_fileno
+# define es_fileno_unlocked   gpgrt_fileno_unlocked
+# define es_syshd             gpgrt_syshd
+# define es_syshd_unlocked    gpgrt_syshd_unlocked
+# define es_stdin             _gpgrt_get_std_stream (0)
+# define es_stdout            _gpgrt_get_std_stream (1)
+# define es_stderr            _gpgrt_get_std_stream (2)
+# define es_flockfile         gpgrt_flockfile
+# define es_ftrylockfile      gpgrt_ftrylockfile
+# define es_funlockfile       gpgrt_funlockfile
+# define es_feof              gpgrt_feof
+# define es_feof_unlocked     gpgrt_feof_unlocked
+# define es_ferror            gpgrt_ferror
+# define es_ferror_unlocked   gpgrt_ferror_unlocked
+# define es_clearerr          gpgrt_clearerr
+# define es_clearerr_unlocked gpgrt_clearerr_unlocked
+# define es_pending           gpgrt_pending
+# define es_pending_unlocked  gpgrt_pending_unlocked
+# define es_fflush            gpgrt_fflush
+# define es_fseek             gpgrt_fseek
+# define es_fseeko            gpgrt_fseeko
+# define es_ftruncate         gpgrt_ftruncate
+# define es_ftell             gpgrt_ftell
+# define es_ftello            gpgrt_ftello
+# define es_rewind            gpgrt_rewind
+# define es_fgetc             gpgrt_fgetc
+# define es_fputc             gpgrt_fputc
+# define es_getc_unlocked     gpgrt_getc_unlocked
+# define es_putc_unlocked     gpgrt_putc_unlocked
+# define es_getc              gpgrt_getc
+# define es_putc              gpgrt_putc
+# define es_ungetc            gpgrt_ungetc
+# define es_read              gpgrt_read
+# define es_write             gpgrt_write
+# define es_write_sanitized   gpgrt_write_sanitized
+# define es_write_hexstring   gpgrt_write_hexstring
+# define es_fread             gpgrt_fread
+# define es_fwrite            gpgrt_fwrite
+# define es_fgets             gpgrt_fgets
+# define es_fputs             gpgrt_fputs
+# define es_fputs_unlocked    gpgrt_fputs_unlocked
+# define es_getline           gpgrt_getline
+# define es_read_line         gpgrt_read_line
+# define es_free              gpgrt_free
+# define es_fprintf           gpgrt_fprintf
+# define es_fprintf_unlocked  gpgrt_fprintf_unlocked
+# define es_printf            gpgrt_printf
+# define es_printf_unlocked   gpgrt_printf_unlocked
+# define es_vfprintf          gpgrt_vfprintf
+# define es_vfprintf_unlocked gpgrt_vfprintf_unlocked
+# define es_setvbuf           gpgrt_setvbuf
+# define es_setbuf            gpgrt_setbuf
+# define es_set_binary        gpgrt_set_binary
+# define es_set_nonblock      gpgrt_set_nonblock
+# define es_get_nonblock      gpgrt_get_nonblock
+# define es_poll              gpgrt_poll
+# define es_tmpfile           gpgrt_tmpfile
+# define es_opaque_set        gpgrt_opaque_set
+# define es_opaque_get        gpgrt_opaque_get
+# define es_fname_set         gpgrt_fname_set
+# define es_fname_get         gpgrt_fname_get
+# define es_asprintf          gpgrt_asprintf
+# define es_vasprintf         gpgrt_vasprintf
+# define es_bsprintf          gpgrt_bsprintf
+# define es_vbsprintf         gpgrt_vbsprintf
+#endif /*GPGRT_ENABLE_ES_MACROS*/
+
+
+
+/*
+ * Base64 encode and decode functions.
+ */
+
+struct _gpgrt_b64state;
+typedef struct _gpgrt_b64state *gpgrt_b64state_t;
+
+gpgrt_b64state_t gpgrt_b64enc_start (gpgrt_stream_t stream, const char *title);
+gpg_err_code_t   gpgrt_b64enc_write (gpgrt_b64state_t state,
+                                     const void *buffer, size_t nbytes);
+gpg_err_code_t   gpgrt_b64enc_finish (gpgrt_b64state_t state);
+
+gpgrt_b64state_t gpgrt_b64dec_start (const char *title);
+gpg_error_t      gpgrt_b64dec_proc (gpgrt_b64state_t state,
+                                    void *buffer, size_t length,
+                                    size_t *r_nbytes);
+gpg_error_t      gpgrt_b64dec_finish (gpgrt_b64state_t state);
+
+
+
+/*
+ * Logging functions
+ */
+
+/* Flag values for gpgrt_log_set_prefix. */
+#define GPGRT_LOG_WITH_PREFIX  1
+#define GPGRT_LOG_WITH_TIME    2
+#define GPGRT_LOG_WITH_PID     4
+#define GPGRT_LOG_RUN_DETACHED 256
+#define GPGRT_LOG_NO_REGISTRY  512
+
+/* Log levels as used by gpgrt_log.  */
+enum gpgrt_log_levels
+  {
+    GPGRT_LOGLVL_BEGIN,
+    GPGRT_LOGLVL_CONT,
+    GPGRT_LOGLVL_INFO,
+    GPGRT_LOGLVL_WARN,
+    GPGRT_LOGLVL_ERROR,
+    GPGRT_LOGLVL_FATAL,
+    GPGRT_LOGLVL_BUG,
+    GPGRT_LOGLVL_DEBUG
+  };
+
+
+/* The next 4 functions are not thread-safe - call them early.  */
+void gpgrt_log_set_sink (const char *name, gpgrt_stream_t stream, int fd);
+void gpgrt_log_set_socket_dir_cb (const char *(*fnc)(void));
+void gpgrt_log_set_pid_suffix_cb (int (*cb)(unsigned long *r_value));
+void gpgrt_log_set_prefix (const char *text, unsigned int flags);
+
+int  gpgrt_get_errorcount (int clear);
+void gpgrt_inc_errorcount (void);
+const char *gpgrt_log_get_prefix (unsigned int *flags);
+int  gpgrt_log_test_fd (int fd);
+int  gpgrt_log_get_fd (void);
+gpgrt_stream_t gpgrt_log_get_stream (void);
+
+void gpgrt_log (int level, const char *fmt, ...) GPGRT_ATTR_PRINTF(2,3);
+void gpgrt_logv (int level, const char *fmt, va_list arg_ptr);
+void gpgrt_logv_prefix (int level, const char *prefix,
+                              const char *fmt, va_list arg_ptr);
+void gpgrt_log_string (int level, const char *string);
+void gpgrt_log_bug (const char *fmt, ...)    GPGRT_ATTR_NR_PRINTF(1,2);
+void gpgrt_log_fatal (const char *fmt, ...)  GPGRT_ATTR_NR_PRINTF(1,2);
+void gpgrt_log_error (const char *fmt, ...)  GPGRT_ATTR_PRINTF(1,2);
+void gpgrt_log_info (const char *fmt, ...)   GPGRT_ATTR_PRINTF(1,2);
+void gpgrt_log_debug (const char *fmt, ...)  GPGRT_ATTR_PRINTF(1,2);
+void gpgrt_log_debug_string (const char *string,
+                             const char *fmt, ...) GPGRT_ATTR_PRINTF(2,3);
+void gpgrt_log_printf (const char *fmt, ...) GPGRT_ATTR_PRINTF(1,2);
+void gpgrt_log_printhex (const void *buffer, size_t length,
+                         const char *fmt, ...) GPGRT_ATTR_PRINTF(3,4);
+void gpgrt_log_clock (const char *fmt, ...) GPGRT_ATTR_PRINTF(1,2);
+void gpgrt_log_flush (void);
+void _gpgrt_log_assert (const char *expr, const char *file, int line,
+                        const char *func) GPGRT_ATTR_NORETURN;
+
+#ifdef GPGRT_HAVE_MACRO_FUNCTION
+# define gpgrt_assert(expr)                                     \
+  ((expr)                                                       \
+   ? (void) 0                                                   \
+   : _gpgrt_log_assert (#expr, __FILE__, __LINE__, __FUNCTION__))
+#else /*!GPGRT_HAVE_MACRO_FUNCTION*/
+# define gpgrt_assert(expr)                                     \
+  ((expr)                                                       \
+   ? (void) 0                                                   \
+   : _gpgrt_log_assert (#expr, __FILE__, __LINE__, NULL))
+#endif /*!GPGRT_HAVE_MACRO_FUNCTION*/
+
+#ifdef GPGRT_ENABLE_LOG_MACROS
+# define log_get_errorcount      gpgrt_get_errorcount
+# define log_inc_errorcount      gpgrt_inc_errorcount
+# define log_set_file(a)         gpgrt_log_set_sink ((a), NULL, -1)
+# define log_set_fd(a)           gpgrt_log_set_sink (NULL, NULL, (a))
+# define log_set_stream(a)       gpgrt_log_set_sink (NULL, (a), -1)
+# define log_set_socket_dir_cb   gpgrt_log_set_socket_dir_cb
+# define log_set_pid_suffix_cb   gpgrt_log_set_pid_suffix_cb
+# define log_set_prefix          gpgrt_log_set_prefix
+# define log_get_prefix          gpgrt_log_get_prefix
+# define log_test_fd             gpgrt_log_test_fd
+# define log_get_fd              gpgrt_log_get_fd
+# define log_get_stream          gpgrt_log_get_stream
+# define log_log                 gpgrt_log
+# define log_logv                gpgrt_logv
+# define log_logv_prefix         gpgrt_logv_prefix
+# define log_string              gpgrt_log_string
+# define log_bug                 gpgrt_log_bug
+# define log_fatal               gpgrt_log_fatal
+# define log_error               gpgrt_log_error
+# define log_info                gpgrt_log_info
+# define log_debug               gpgrt_log_debug
+# define log_debug_string        gpgrt_log_debug_string
+# define log_printf              gpgrt_log_printf
+# define log_printhex            gpgrt_log_printhex
+# define log_clock               gpgrt_log_clock
+# define log_flush               gpgrt_log_flush
+# ifdef GPGRT_HAVE_MACRO_FUNCTION
+#  define log_assert(expr)                                      \
+  ((expr)                                                       \
+   ? (void) 0                                                   \
+   : _gpgrt_log_assert (#expr, __FILE__, __LINE__, __FUNCTION__))
+# else /*!GPGRT_HAVE_MACRO_FUNCTION*/
+#  define log_assert(expr)                                      \
+  ((expr)                                                       \
+   ? (void) 0                                                   \
+   : _gpgrt_log_assert (#expr, __FILE__, __LINE__, NULL))
+# endif /*!GPGRT_HAVE_MACRO_FUNCTION*/
+
+#endif /*GPGRT_ENABLE_LOG_MACROS*/
+
+
+/*
+ * Spawn functions  (Not yet available)
+ */
+#define GPGRT_SPAWN_NONBLOCK   16 /* Set the streams to non-blocking.      */
+#define GPGRT_SPAWN_RUN_ASFW   64 /* Use AllowSetForegroundWindow on W32.  */
+#define GPGRT_SPAWN_DETACHED  128 /* Start the process in the background.  */
+
+#if 0
+
+/* Function and convenience macros to create pipes.  */
+gpg_err_code_t gpgrt_make_pipe (int filedes[2], gpgrt_stream_t *r_fp,
+                                int direction, int nonblock);
+#define gpgrt_create_pipe(a)              gpgrt_make_pipe ((a),NULL,  0,  0);
+#define gpgrt_create_inbound_pipe(a,b,c)  gpgrt_make_pipe ((a), (b), -1,(c));
+#define gpgrt_create_outbound_pipe(a,b,c) gpgrt_make_pipe ((a), (b),  1,(c));
+
+
+/* Fork and exec PGMNAME.  */
+gpg_err_code_t gpgrt_spawn_process (const char *pgmname, const char *argv[],
+                                    int *execpt, void (*preexec)(void),
+                                    unsigned int flags,
+                                    gpgrt_stream_t *r_infp,
+                                    gpgrt_stream_t *r_outfp,
+                                    gpgrt_stream_t *r_errfp,
+                                    pid_t *pid);
+
+/* Fork and exec PGNNAME and connect the process to the given FDs.  */
+gpg_err_code_t gpgrt_spawn_process_fd (const char *pgmname, const char *argv[],
+                                       int infd, int outfd, int errfd,
+                                       pid_t *pid);
+
+/* Fork and exec PGMNAME as a detached process.  */
+gpg_err_code_t gpgrt_spawn_process_detached (const char *pgmname,
+                                             const char *argv[],
+                                             const char *envp[] );
+
+/* Wait for a single process.  */
+gpg_err_code_t gpgrt_wait_process (const char *pgmname, pid_t pid, int hang,
+                                int *r_exitcode);
+
+/* Wait for a multiple processes.  */
+gpg_err_code_t gpgrt_wait_processes (const char **pgmnames, pid_t *pids,
+                                     size_t count, int hang, int *r_exitcodes);
+
+/* Kill the process identified by PID.  */
+void gpgrt_kill_process (pid_t pid);
+
+/* Release process resources identified by PID.  */
+void gpgrt_release_process (pid_t pid);
+
+#endif /*0*/
+
+
+
+/*
+ * Option parsing.
+ */
+
+struct _gpgrt_argparse_internal_s;
+typedef struct
+{
+  int  *argc;	      /* Pointer to ARGC (value subject to change). */
+  char ***argv;	      /* Pointer to ARGV (value subject to change). */
+  unsigned int flags; /* Global flags.  May be set prior to calling the
+                         parser.  The parser may change the value.  */
+  int err;            /* Print error description for last option.
+                         Either 0,  ARGPARSE_PRINT_WARNING or
+                         ARGPARSE_PRINT_ERROR.  */
+  unsigned int lineno;/* The current line number.  */
+  int r_opt; 	      /* Returns option code. */
+  int r_type;	      /* Returns type of option value.  */
+  union {
+    int   ret_int;
+    long  ret_long;
+    unsigned long ret_ulong;
+    char *ret_str;
+  } r;		      /* Return values */
+
+  struct _gpgrt_argparse_internal_s *internal;
+} gpgrt_argparse_t;
+
+
+typedef struct
+{
+  int          short_opt;
+  const char  *long_opt;
+  unsigned int flags;
+  const char  *description; /* Optional description. */
+} gpgrt_opt_t;
+
+
+#ifdef GPGRT_ENABLE_ARGPARSE_MACROS
+
+/* Global flags for (gpgrt_argparse_t).flags.  */
+#define ARGPARSE_FLAG_KEEP        1  /* Do not remove options form argv.     */
+#define ARGPARSE_FLAG_ALL         2  /* Do not stop at last option but return
+                                        remaining args with R_OPT set to -1. */
+#define ARGPARSE_FLAG_MIXED       4  /* Assume options and args are mixed.   */
+#define ARGPARSE_FLAG_NOSTOP      8  /* Do not stop processing at "--".      */
+#define ARGPARSE_FLAG_ARG0       16  /* Do not skip the first arg.           */
+#define ARGPARSE_FLAG_ONEDASH    32  /* Allow long options with one dash.    */
+#define ARGPARSE_FLAG_NOVERSION  64  /* No output for "--version".           */
+#define ARGPARSE_FLAG_RESET     128  /* Request to reset the internal state. */
+#define ARGPARSE_FLAG_STOP_SEEN 256  /* Set to true if a "--" has been seen. */
+#define ARGPARSE_FLAG_NOLINENO  512  /* Do not zero the lineno field.         */
+
+/* Constants for (gpgrt_argparse_t).err.  */
+#define ARGPARSE_PRINT_WARNING  1    /* Print a diagnostic.                  */
+#define ARGPARSE_PRINT_ERROR    2    /* Print a diagnostic and call exit.    */
+
+/* Special return values of gpgrt_argparse.  */
+#define ARGPARSE_IS_ARG            (-1)
+#define ARGPARSE_INVALID_OPTION    (-2)
+#define ARGPARSE_MISSING_ARG       (-3)
+#define ARGPARSE_KEYWORD_TOO_LONG  (-4)
+#define ARGPARSE_READ_ERROR        (-5)
+#define ARGPARSE_UNEXPECTED_ARG    (-6)
+#define ARGPARSE_INVALID_COMMAND   (-7)
+#define ARGPARSE_AMBIGUOUS_OPTION  (-8)
+#define ARGPARSE_AMBIGUOUS_COMMAND (-9)
+#define ARGPARSE_INVALID_ALIAS     (-10)
+#define ARGPARSE_OUT_OF_CORE       (-11)
+#define ARGPARSE_INVALID_ARG       (-12)
+
+/* Flags for the option descriptor (gpgrt_opt_t)->flags.  Note that
+ * a TYPE constant may be or-ed with the OPT constants.  */
+#define ARGPARSE_TYPE_NONE        0  /* Does not take an argument.        */
+#define ARGPARSE_TYPE_INT         1  /* Takes an int argument.            */
+#define ARGPARSE_TYPE_STRING      2  /* Takes a string argument.          */
+#define ARGPARSE_TYPE_LONG        3  /* Takes a long argument.            */
+#define ARGPARSE_TYPE_ULONG       4  /* Takes an unsigned long argument.  */
+#define ARGPARSE_OPT_OPTIONAL (1<<3) /* Argument is optional.             */
+#define ARGPARSE_OPT_PREFIX   (1<<4) /* Allow 0x etc. prefixed values.    */
+#define ARGPARSE_OPT_IGNORE   (1<<6) /* Ignore command or option.         */
+#define ARGPARSE_OPT_COMMAND  (1<<7) /* The argument is a command.        */
+
+/* A set of macros to make option definitions easier to read.  */
+#define ARGPARSE_x(s,l,t,f,d) \
+     { (s), (l), ARGPARSE_TYPE_ ## t | (f), (d) }
+
+#define ARGPARSE_s(s,l,t,d) \
+     { (s), (l), ARGPARSE_TYPE_ ## t, (d) }
+#define ARGPARSE_s_n(s,l,d) \
+     { (s), (l), ARGPARSE_TYPE_NONE, (d) }
+#define ARGPARSE_s_i(s,l,d) \
+     { (s), (l), ARGPARSE_TYPE_INT, (d) }
+#define ARGPARSE_s_s(s,l,d) \
+     { (s), (l), ARGPARSE_TYPE_STRING, (d) }
+#define ARGPARSE_s_l(s,l,d) \
+     { (s), (l), ARGPARSE_TYPE_LONG, (d) }
+#define ARGPARSE_s_u(s,l,d) \
+     { (s), (l), ARGPARSE_TYPE_ULONG, (d) }
+
+#define ARGPARSE_o(s,l,t,d) \
+     { (s), (l), (ARGPARSE_TYPE_ ## t  | ARGPARSE_OPT_OPTIONAL), (d) }
+#define ARGPARSE_o_n(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_NONE   | ARGPARSE_OPT_OPTIONAL), (d) }
+#define ARGPARSE_o_i(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_INT    | ARGPARSE_OPT_OPTIONAL), (d) }
+#define ARGPARSE_o_s(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_STRING | ARGPARSE_OPT_OPTIONAL), (d) }
+#define ARGPARSE_o_l(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_LONG   | ARGPARSE_OPT_OPTIONAL), (d) }
+#define ARGPARSE_o_u(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_ULONG  | ARGPARSE_OPT_OPTIONAL), (d) }
+
+#define ARGPARSE_p(s,l,t,d) \
+     { (s), (l), (ARGPARSE_TYPE_ ## t  | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_p_n(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_NONE   | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_p_i(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_INT    | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_p_s(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_STRING | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_p_l(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_LONG   | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_p_u(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_ULONG  | ARGPARSE_OPT_PREFIX), (d) }
+
+#define ARGPARSE_op(s,l,t,d) \
+     { (s), (l), (ARGPARSE_TYPE_ ## t \
+                  | ARGPARSE_OPT_OPTIONAL | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_op_n(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_NONE \
+                  | ARGPARSE_OPT_OPTIONAL | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_op_i(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_INT \
+                  | ARGPARSE_OPT_OPTIONAL | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_op_s(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_STRING \
+                  | ARGPARSE_OPT_OPTIONAL | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_op_l(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_LONG \
+                  | ARGPARSE_OPT_OPTIONAL | ARGPARSE_OPT_PREFIX), (d) }
+#define ARGPARSE_op_u(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_ULONG \
+                  | ARGPARSE_OPT_OPTIONAL | ARGPARSE_OPT_PREFIX), (d) }
+
+#define ARGPARSE_c(s,l,d) \
+     { (s), (l), (ARGPARSE_TYPE_NONE | ARGPARSE_OPT_COMMAND), (d) }
+
+#define ARGPARSE_ignore(s,l) \
+     { (s), (l), (ARGPARSE_OPT_IGNORE), "@" }
+
+#define ARGPARSE_group(s,d) \
+     { (s), NULL, 0, (d) }
+
+/* Mark the end of the list (mandatory).  */
+#define ARGPARSE_end() \
+     { 0, NULL, 0, NULL }
+
+#endif /* GPGRT_ENABLE_ARGPARSE_MACROS */
+
+/* Take care: gpgrt_argparse keeps state in ARG and requires that
+ * either ARGPARSE_FLAG_RESET is used after OPTS has been changed or
+ * gpgrt_argparse (NULL, ARG, NULL) is called first.  */
+int gpgrt_argparse (gpgrt_stream_t fp,
+                    gpgrt_argparse_t *arg, gpgrt_opt_t *opts);
+void gpgrt_usage (int level);
+const char *gpgrt_strusage (int level);
+void gpgrt_set_strusage (const char *(*f)(int));
+void gpgrt_set_usage_outfnc (int (*f)(int, const char *));
+void gpgrt_set_fixed_string_mapper (const char *(*f)(const char*));
+
+
+/*
+ * Various helper functions
+ */
+
+/* Compare arbitrary version strings.  For the standard m.n.o version
+ * numbering scheme a LEVEL of 3 is suitable; see the manual.  */
+int gpgrt_cmp_version (const char *a, const char *b, int level);
+
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif	/* GPGRT_H */
+#endif	/* GPG_ERROR_H */
+/*
+Local Variables:
+buffer-read-only: t
+End:
+*/
diff --git a/src/gpgrt-int.h b/src/gpgrt-int.h
index a13f5fb..1b60ebe 100644
--- a/src/gpgrt-int.h
+++ b/src/gpgrt-int.h
@@ -93,7 +93,7 @@
 #endif
 
 
-
+typedef int pid_t;
 /*
  * Local error function prototypes.
  */
diff --git a/src/logging.c b/src/logging.c
index 329982b..95c5e1b 100644
--- a/src/logging.c
+++ b/src/logging.c
@@ -38,13 +38,14 @@
 #  include <winsock2.h>
 # endif
 # include <windows.h>
+# include <io.h>
+#include <WS2tcpip.h>
 #else /*!HAVE_W32_SYSTEM*/
 # include <sys/socket.h>
 # include <sys/un.h>
 # include <netinet/in.h>
 # include <arpa/inet.h>
 #endif /*!HAVE_W32_SYSTEM*/
-#include <unistd.h>
 #include <fcntl.h>
 /* #include <execinfo.h> */
 
@@ -53,6 +54,15 @@
 
 
 #ifdef HAVE_W32_SYSTEM
+# ifndef S_IRUSR
+#  define S_IRUSR 0x400
+# endif
+# ifndef S_IWUSR
+#  define S_IWUSR 0x200
+# endif
+# ifndef S_IXUSR
+#  define S_IXUSR 0x100
+# endif
 # ifndef S_IRWXG
 #  define S_IRGRP S_IRUSR
 #  define S_IWGRP S_IWUSR
@@ -89,7 +99,7 @@
 
 
 static estream_t logstream;
-static int log_socket = -1;
+static SOCKET log_socket = -1;
 static char prefix_buffer[80];
 static int with_time;
 static int with_prefix;
@@ -138,7 +148,7 @@ _gpgrt_inc_errorcount (void)
    to a socket.  */
 struct fun_cookie_s
 {
-  int fd;
+  SOCKET fd;
   int quiet;
   int want_socket;
   int is_socket;
@@ -148,7 +158,6 @@ struct fun_cookie_s
   char name[1];
 };
 
-
 /* Write NBYTES of BUFFER to file descriptor FD. */
 static int
 writen (int fd, const void *buffer, size_t nbytes, int is_socket)
@@ -164,10 +173,10 @@ writen (int fd, const void *buffer, size_t nbytes, int is_socket)
     {
 #ifdef HAVE_W32_SYSTEM
       if (is_socket)
-        nwritten = send (fd, buf, nleft, 0);
+        nwritten = send (fd, buf, (int)nleft, 0);
       else
 #endif
-        nwritten = write (fd, buf, nleft);
+        nwritten = _write (fd, buf, nleft);
 
       if (nwritten < 0 && errno == EINTR)
         continue;
@@ -367,8 +376,7 @@ fun_writer (void *cookie_arg, const void *buffer, size_t size)
       cookie->fd = addrlen? socket (pf, SOCK_STREAM, 0) : -1;
       if (cookie->fd == -1)
         {
-          if (!cookie->quiet && !running_detached
-              && isatty (_gpgrt_fileno (es_stderr)))
+          if (!cookie->quiet && !running_detached)
             _gpgrt_fprintf (es_stderr,
                             "failed to create socket for logging: %s\n",
                             strerror (errno));
@@ -377,8 +385,7 @@ fun_writer (void *cookie_arg, const void *buffer, size_t size)
         {
           if (connect (cookie->fd, srvr_addr, addrlen) == -1)
             {
-              if (!cookie->quiet && !running_detached
-                  && isatty (_gpgrt_fileno (es_stderr)))
+              if (!cookie->quiet && !running_detached)
                 _gpgrt_fprintf (es_stderr, "can't connect to '%s%s': %s\n",
                                 cookie->name, name_for_err, strerror(errno));
               sock_close (cookie->fd);
@@ -536,7 +543,7 @@ set_file_fd (const char *name, int fd, estream_t stream)
   else
     {
       do
-        cookie->fd = open (name, O_WRONLY|O_APPEND|O_CREAT,
+        cookie->fd = _open (name, O_WRONLY|O_APPEND|O_CREAT,
                            (S_IRUSR|S_IRGRP|S_IROTH|S_IWUSR|S_IWGRP|S_IWOTH));
       while (cookie->fd == -1 && errno == EINTR);
     }
@@ -826,10 +833,10 @@ print_prefix (int level, int leading_backspace)
           if (get_pid_suffix_cb && (pidfmt=get_pid_suffix_cb (&pidsuf)))
             rc = _gpgrt_fprintf_unlocked (logstream,
                                           pidfmt == 1? "[%u.%lu]":"[%u.%lx]",
-                                          (unsigned int)getpid (), pidsuf);
+                                          (unsigned int)GetCurrentProcessId (), pidsuf);
           else
             rc = _gpgrt_fprintf_unlocked (logstream, "[%u]",
-                                          (unsigned int)getpid ());
+                                          (unsigned int)GetCurrentProcessId ());
           if (rc > 0)
             length += rc;
         }
@@ -892,7 +899,7 @@ _gpgrt_logv_internal (int level, int ignore_arg_ptr, const char *extrastring,
 
   if (!logstream)
     {
-#ifdef HAVE_W32_SYSTEM
+#if defined(HAVE_W32_SYSTEM) && !defined(MS_APP)
       char *tmp;
 
       tmp = (no_registry
diff --git a/src/sysutils.c b/src/sysutils.c
index c3aaf42..56adb01 100644
--- a/src/sysutils.c
+++ b/src/sysutils.c
@@ -22,10 +22,11 @@
 #include <stdlib.h>
 #include <stdint.h>
 #include <string.h>
-#include <unistd.h>
 #include <errno.h>
 #ifdef HAVE_W32_SYSTEM
 # include <windows.h>
+# include "w32-add.h"
+# include <io.h>
 #endif
 #ifdef HAVE_STAT
 # include <sys/stat.h>
@@ -41,10 +42,10 @@
 int
 _gpgrt_fd_valid_p (int fd)
 {
-  int d = dup (fd);
+  int d = _dup (fd);
   if (d < 0)
     return 0;
-  close (d);
+  _close (d);
   return 1;
 }
 
@@ -63,42 +64,54 @@ _gpgrt_getenv (const char *name)
 
 #ifdef HAVE_W32_SYSTEM
   {
-    int len, size;
-    char *result;
+    size_t len, size;
+    wchar_t *resultW;
 
-    len = GetEnvironmentVariable (name, NULL, 0);
+	wchar_t* nameW = utf8_to_wchar(name, strlen(name), &len);
+
+	if (!len || !nameW)
+		return NULL;
+
+    len = GetEnvironmentVariableW (nameW, NULL, 0);
     if (!len && GetLastError () == ERROR_ENVVAR_NOT_FOUND)
       {
         _gpg_err_set_errno (0);
+		free(nameW);
         return NULL;
       }
   again:
     size = len;
-    result = _gpgrt_malloc (size);
-    if (!result)
-      return NULL;
-    len = GetEnvironmentVariable (name, result, size);
+    resultW = _gpgrt_malloc (size);
+	if (!resultW)
+	{
+		free(nameW);
+		return NULL;
+	}
+    len = GetEnvironmentVariableW (nameW, resultW, size);
     if (len >= size)
       {
         /* Changed in the meantime - retry.  */
-        _gpgrt_free (result);
+        _gpgrt_free (resultW);
         goto again;
       }
+	_gpgrt_free(nameW);
     if (!len && GetLastError () == ERROR_ENVVAR_NOT_FOUND)
       {
         /* Deleted in the meantime.  */
-        _gpgrt_free (result);
+        _gpgrt_free (resultW);
         _gpg_err_set_errno (0);
         return NULL;
       }
     if (!len)
       {
         /* Other error.  FIXME: We need mapping fucntion. */
-        _gpgrt_free (result);
+        _gpgrt_free (resultW);
         _gpg_err_set_errno (EIO);
         return NULL;
       }
-
+	
+	char* result = wchar_to_native(resultW, len, &size);
+	_gpgrt_free(resultW);
     return result;
   }
 #else /*!HAVE_W32_SYSTEM*/
@@ -134,13 +147,24 @@ _gpgrt_setenv (const char *name, const char *value, int overwrite)
    * values - however, too much existing code still uses getenv.  */
   {
     int exists;
-    char tmpbuf[10];
+    wchar_t tmpbuf[10];
     char *buf;
+	wchar_t* nameW;
+	size_t nlength, vlength;
+	wchar_t* valueW;
+
+	nameW = utf8_to_wchar(name, strlen(name), &nlength);
+	if (!nlength || !nameW)
+		return GPG_ERR_EINVAL;
 
     if (!value && overwrite)
       {
-        if (!SetEnvironmentVariable (name, NULL))
-          return GPG_ERR_EINVAL;
+		if (!SetEnvironmentVariableW(nameW, NULL))
+		{
+			_gpgrt_free(nameW);
+			return GPG_ERR_EINVAL;
+		}
+		_gpgrt_free(nameW);
         if (getenv (name))
           {
             /* Ugly: Leaking memory.  */
@@ -153,9 +177,21 @@ _gpgrt_setenv (const char *name, const char *value, int overwrite)
         return 0;
       }
 
-    exists = GetEnvironmentVariable (name, tmpbuf, sizeof tmpbuf);
-    if ((! exists || overwrite) && !SetEnvironmentVariable (name, value))
-      return GPG_ERR_EINVAL; /* (Might also be ENOMEM.) */
+    exists = GetEnvironmentVariableW (nameW, tmpbuf, sizeof tmpbuf);
+	valueW = utf8_to_wchar(value, strlen(value), &vlength);
+	if (!vlength || !valueW)
+	{
+		_gpgrt_free(nameW);
+		return GPG_ERR_EINVAL;
+	}
+	if ((!exists || overwrite) && !SetEnvironmentVariableW(nameW, valueW))
+	{
+		_gpgrt_free(nameW);
+		_gpgrt_free(valueW);
+		return GPG_ERR_EINVAL; /* (Might also be ENOMEM.) */
+	}
+	_gpgrt_free(nameW);
+	_gpgrt_free(valueW);
     if (overwrite || !getenv (name))
       {
         /* Ugly: Leaking memory.  */
@@ -270,11 +306,12 @@ modestr_to_mode (const char *modestr)
 gpg_err_code_t
 _gpgrt_mkdir (const char *name, const char *modestr)
 {
-#ifdef HAVE_W32CE_SYSTEM
+#if 1
   wchar_t *wname;
+  size_t length;
   (void)modestr;
 
-  wname = utf8_to_wchar (name);
+  wname = utf8_to_wchar (name, strlen(name), &length);
   if (!wname)
     return _gpg_err_code_from_syserror ();
   if (!CreateDirectoryW (wname, NULL))
@@ -305,9 +342,13 @@ _gpgrt_mkdir (const char *name, const char *modestr)
 gpg_err_code_t
 _gpgrt_chdir (const char *name)
 {
-  if (chdir (name))
+#ifdef MS_APP
+	return 0;
+#else
+  if (_chdir (name))
     return _gpg_err_code_from_syserror ();
   return 0;
+#endif
 }
 
 
@@ -324,7 +365,7 @@ _gpgrt_getcwd (void)
       buffer = xtrymalloc (size+1);
       if (!buffer)
         return NULL;
-#ifdef HAVE_W32CE_SYSTEM
+#if 1
       strcpy (buffer, "/");  /* Always "/".  */
       return buffer;
 #else
diff --git a/src/visibility.c b/src/visibility.c
index d754032..049a023 100644
--- a/src/visibility.c
+++ b/src/visibility.c
@@ -1187,7 +1187,11 @@ gpgrt_cmp_version (const char *a, const char *b, int level)
 char *
 gpgrt_w32_reg_query_string (const char *root, const char *dir, const char *name)
 {
+#ifdef MS_APP
+	return NULL;
+#else
   return _gpgrt_w32_reg_query_string (root, dir, name);
+#endif
 }
 
 #endif /*HAVE_W32_SYSTEM*/
diff --git a/src/w32-add.h b/src/w32-add.h
index 3428961..3615b56 100644
--- a/src/w32-add.h
+++ b/src/w32-add.h
@@ -1,7 +1,7 @@
-## w32-add.h - Snippet to be be included into gpg-error.h.
-## Comments are indicated by a double hash mark.  Due to a
-## peculiarity of the script the first used line must not
-## start with a hash mark.
+//## w32-add.h - Snippet to be be included into gpg-error.h.
+//## Comments are indicated by a double hash mark.  Due to a
+//## peculiarity of the script the first used line must not
+//## start with a hash mark.
 
 /* Decide whether to use the format_arg attribute.  */
 #if _GPG_ERR_GCC_VERSION > 20800
@@ -10,6 +10,9 @@
 # define _GPG_ERR_ATTR_FORMAT_ARG(a)
 #endif
 
+#include <inttypes.h>
+#include "config.h"
+
 /* A lean gettext implementation based on GNU style mo files which are
    required to be encoded in UTF-8.  There is a limit on 65534 entries
    to save some RAM.  Only Germanic plural rules are supported.  */
@@ -25,6 +28,10 @@ const char *_gpg_w32_dngettext (const char *domainname, const char *msgid1,
             _GPG_ERR_ATTR_FORMAT_ARG (2) _GPG_ERR_ATTR_FORMAT_ARG (3);
 const char *_gpg_w32_gettext_localename (void);
 int _gpg_w32_gettext_use_utf8 (int value);
+wchar_t*
+utf8_to_wchar(const char* string, size_t length, size_t* retlen);
+char*
+wchar_to_native(const wchar_t* string, size_t length, size_t* retlen);
 
 #ifdef GPG_ERR_ENABLE_GETTEXT_MACROS
 # define bindtextdomain(a,b) _gpg_w32_bindtextdomain ((a), (b))
@@ -42,6 +49,7 @@ int _gpg_w32_gettext_use_utf8 (int value);
 void gpgrt_w32_override_locale (const char *name, unsigned short langid);
 
 
+#if 0
 /* A simple iconv implementation w/o the need for an extra DLL.  */
 struct _gpgrt_w32_iconv_s;
 typedef struct _gpgrt_w32_iconv_s *gpgrt_w32_iconv_t;
@@ -52,6 +60,7 @@ int     gpgrt_w32_iconv_close (gpgrt_w32_iconv_t cd);
 size_t  gpgrt_w32_iconv (gpgrt_w32_iconv_t cd,
                          const char **inbuf, size_t *inbytesleft,
                          char **outbuf, size_t *outbytesleft);
+#endif
 
 #ifdef GPGRT_ENABLE_W32_ICONV_MACROS
 # define ICONV_CONST const
diff --git a/src/w32-gettext.c b/src/w32-gettext.c
index 11e4f3d..dba0b01 100644
--- a/src/w32-gettext.c
+++ b/src/w32-gettext.c
@@ -668,7 +668,7 @@ my_nl_locale_name (const char *categoryname)
     }
   else
     {
-      LCID lcid;
+      LCID lcid = 0;
 
       /* Let the user override the system settings through environment
        *  variables, as on POSIX systems.  */
@@ -685,10 +685,12 @@ my_nl_locale_name (const char *categoryname)
 #endif /*!HAVE_W32CE_SYSTEM*/
 
       /* Use native Win32 API locale ID.  */
+#ifndef MS_APP
 #ifdef HAVE_W32CE_SYSTEM
       lcid = GetSystemDefaultLCID ();
 #else
       lcid = GetThreadLocale ();
+#endif
 #endif
       /* Strip off the sorting rules, keep only the language part.  */
       langid = LANGIDFROMLCID (lcid);
@@ -1239,6 +1241,8 @@ free_domain (struct loaded_domain *domain)
   jnlib_free (domain);
 }
 
+wchar_t*
+utf8_to_wchar(const char* string, size_t length, size_t* retlen);
 
 static struct loaded_domain *
 load_domain (const char *filename)
@@ -1249,13 +1253,26 @@ load_domain (const char *filename)
   struct loaded_domain *domain = NULL;
   size_t to_read;
   char *read_ptr;
+  wchar_t* filenameW;
+  size_t length;
+
+  filenameW = utf8_to_wchar(filename, strlen(filename), &length);
+  if (!length || !filenameW)
+	  return NULL;
 
-  fh = CreateFileA (filename, GENERIC_READ, FILE_SHARE_WRITE, NULL,
+#ifdef MS_APP
+  fh = CreateFile2 (filenameW, GENERIC_READ, FILE_SHARE_WRITE, 
+                    OPEN_EXISTING, NULL);
+#else
+  fh = CreateFileW (filenameW, GENERIC_READ, FILE_SHARE_WRITE, NULL,
                     OPEN_EXISTING, 0, NULL);
+#endif
+
+  gpgrt_free(filenameW);
   if (fh == INVALID_HANDLE_VALUE)
     return NULL;
 
-  size = GetFileSize (fh, NULL);
+  size = GetFileSizeEx (fh, NULL);
   if (size == INVALID_FILE_SIZE)
     {
       CloseHandle (fh);
@@ -1355,7 +1372,7 @@ load_domain (const char *filename)
    string STRING.  Caller must free this value. On failure returns
    NULL.  The result of calling this function with STRING set to NULL
    is not defined. */
-static wchar_t *
+wchar_t *
 utf8_to_wchar (const char *string, size_t length, size_t *retlen)
 {
   int n;
@@ -1392,7 +1409,7 @@ utf8_to_wchar (const char *string, size_t length, size_t *retlen)
    Caller must free this value. On failure returns NULL.
    The result of calling this function with STRING set to NULL
    is not defined. */
-static char *
+char *
 wchar_to_native (const wchar_t *string, size_t length, size_t *retlen)
 {
   int n;
