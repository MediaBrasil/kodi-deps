diff --git a/CMakeLists.txt b/CMakeLists.txt
new file mode 100644
index 0000000..87854ec
--- /dev/null
+++ b/CMakeLists.txt
@@ -0,0 +1,139 @@
+cmake_minimum_required(VERSION 3.2)
+
+project(libass LANGUAGES C CXX)
+
+  find_package(iconv REQUIRED NO_MODULE)
+  find_package(freetype 2.6 REQUIRED NO_MODULE)
+  find_package(fribidi REQUIRED NO_MODULE)
+
+add_library(libass
+  libass/ass_bitmap.c
+  libass/ass_bitmap.h
+  libass/ass_blur.c
+  libass/ass_cache.c
+  libass/ass_cache.h
+  libass/ass_cache_template.h
+  libass/ass_compat.h
+  libass/ass_drawing.c
+  libass/ass_drawing.h
+  libass/ass_font.c
+  libass/ass_font.h
+  libass/ass_fontselect.c
+  libass/ass_fontselect.h
+  libass/ass_func_template.h
+  libass/ass_library.c
+  libass/ass_library.h
+  libass/ass_parse.c
+  libass/ass_parse.h
+  libass/ass_rasterizer.c
+  libass/ass_rasterizer.h
+  libass/ass_rasterizer_c.c
+  libass/ass_render.c
+  libass/ass_render.h
+  libass/ass_render_api.c
+  libass/ass_shaper.c
+  libass/ass_shaper.h
+  libass/ass_string.c
+  libass/ass_string.h
+  libass/ass_strtod.c
+  libass/ass_types.h
+  libass/ass_utils.c
+  libass/ass_utils.h
+  libass/ass.c
+  libass/ass.h
+  )
+
+target_link_libraries(libass
+  PRIVATE
+  freetype::freetype
+  fribidi::fribidi
+  iconv::iconv
+)
+target_compile_definitions(libass
+  PRIVATE
+    CONFIG_RASTERIZER
+    BUILDING_LIBASS
+    CONFIG_ICONV
+)
+
+if(NOT BUILD_SHARED_LIBS)
+  target_compile_definitions(libass PRIVATE ASS_STATIC)
+endif()
+
+target_include_directories(libass
+  INTERFACE
+  $<INSTALL_INTERFACE:include/ass>
+)
+
+if(WINDOWS_STORE)
+  target_compile_definitions(libass
+    PRIVATE
+      MS_APP
+  )
+endif()
+
+if(MSVC)
+  target_sources(libass PRIVATE
+    libass/ass_directwrite.h
+    libass/ass_directwrite.cpp
+  )
+  target_compile_definitions(libass PRIVATE
+    CONFIG_DIRECTWRITE
+  )
+  target_link_libraries(libass PRIVATE dwrite.lib)
+set(CMAKE_DEBUG_POSTFIX "d")
+endif()
+
+set(libass_VERSION 0.13.6)
+include(CMakePackageConfigHelpers)
+write_basic_package_version_file(
+  ${CMAKE_CURRENT_BINARY_DIR}/libass-config-version.cmake
+  VERSION ${libass_VERSION}
+  COMPATIBILITY AnyNewerVersion
+)
+
+install(TARGETS libass EXPORT libass
+  RUNTIME DESTINATION bin
+  ARCHIVE DESTINATION lib
+  LIBRARY DESTINATION lib)
+
+
+install(FILES
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_render.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_shaper.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_types.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_utils.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_bitmap.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_cache.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_cache_template.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_drawing.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_font.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_fontconfig.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_library.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_parse.h
+  ${CMAKE_CURRENT_SOURCE_DIR}/libass/ass_rasterizer.h
+  DESTINATION include/ass)
+
+install(EXPORT libass
+  FILE
+    libass.cmake
+  NAMESPACE
+    libass::
+  DESTINATION
+    lib/cmake/libass
+)
+install(
+  FILES
+    cmake/libass-config.cmake
+    ${CMAKE_CURRENT_BINARY_DIR}/libass-config-version.cmake
+  DESTINATION
+    lib/cmake/libass
+)
+
+if(MSVC AND BUILD_SHARED_LIBS)
+  install(FILES
+    $<TARGET_PDB_FILE:libass>
+    DESTINATION lib
+  )
+endif()
\ No newline at end of file
diff --git a/cmake/libass-config.cmake b/cmake/libass-config.cmake
new file mode 100644
index 0000000..48121c8
--- /dev/null
+++ b/cmake/libass-config.cmake
@@ -0,0 +1 @@
+include(${CMAKE_CURRENT_LIST_DIR}/libass.cmake)
\ No newline at end of file
diff --git a/libass/ass.c b/libass/ass.c
index e8cefc5..8e644f4 100644
--- a/libass/ass.c
+++ b/libass/ass.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <stdio.h>
@@ -28,6 +30,10 @@
 #include <sys/stat.h>
 #include <inttypes.h>
 
+#ifndef HAVE_DIRENT_H
+#include <windows.h>
+#endif
+
 #ifdef CONFIG_ICONV
 #include <iconv.h>
 #endif
@@ -1071,6 +1077,7 @@ out:
 }
 #endif                          // ICONV
 
+
 /**
  * \brief read file contents into newly allocated buffer
  * \param fname file name
@@ -1129,6 +1136,38 @@ char *read_file(ASS_Library *library, char *fname, size_t *bufsize)
     return buf;
 }
 
+#ifndef HAVE_DIRENT_H
+/**
+ * \brief read file contents into newly allocated buffer
+ * \param fname file name
+ * \param bufsize out: file size
+ * \return pointer to file contents. Caller is responsible for its deallocation.
+ */
+char *read_fileW(ASS_Library *library, wchar_t *fname, DWORD fileSize, size_t *bufsize)
+{
+#ifdef MS_APP
+  HANDLE hFile = CreateFile2(fname, GENERIC_READ, FILE_SHARE_READ, 
+                              OPEN_EXISTING,  NULL);
+#else
+  HANDLE hFile = CreateFileW(fname, GENERIC_READ, FILE_SHARE_READ, NULL,
+                              OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+#endif
+
+  if (hFile == INVALID_HANDLE_VALUE)
+    return NULL;
+  
+  char *buf = malloc(fileSize + 1); //room for null
+  if (TRUE != ReadFile(hFile, (void*)buf, fileSize, 0, NULL))
+  {
+    free(buf);
+    ass_msg(library, MSGL_INFO, "Read failed for some reason");
+    return NULL;
+  }
+
+  return buf;
+}
+#endif
+
 /*
  * \param buf pointer to subtitle text in utf-8
  */
diff --git a/libass/ass.h b/libass/ass.h
index c62752e..e1dfd24 100644
--- a/libass/ass.h
+++ b/libass/ass.h
@@ -30,6 +30,19 @@
 extern "C" {
 #endif
 
+#ifdef ASS_STATICLIB
+#  define ASS_EXTERN
+#elif defined(WIN32)
+#  if defined(BUILDING_LIBASS)
+#    define ASS_EXTERN  __declspec(dllexport)
+#  else
+#    define ASS_EXTERN  __declspec(dllimport)
+#  endif
+#elif defined(BUILDING_LIBASS) && defined(ASS_HIDDEN_SYMBOLS)
+#  define ASS_EXTERN ASS_EXTERN_SYMBOL
+#else
+#  define ASS_EXTERN
+#endif
 /*
  * A linked list of images produced by an ass renderer.
  *
@@ -177,7 +190,7 @@ typedef enum {
  * was set to when the library was compiled.
  * \return library version
  */
-int ass_library_version(void);
+ASS_EXTERN int ass_library_version(void);
 
 /**
  * \brief Default Font provider to load fonts in libass' database
@@ -201,13 +214,13 @@ typedef enum {
  * \brief Initialize the library.
  * \return library handle or NULL if failed
  */
-ASS_Library *ass_library_init(void);
+ASS_EXTERN ASS_Library *ass_library_init(void);
 
 /**
  * \brief Finalize the library
  * \param priv library handle
  */
-void ass_library_done(ASS_Library *priv);
+ASS_EXTERN void ass_library_done(ASS_Library *priv);
 
 /**
  * \brief Set additional fonts directory.
@@ -218,14 +231,14 @@ void ass_library_done(ASS_Library *priv);
  * \param priv library handle
  * \param fonts_dir directory with additional fonts
  */
-void ass_set_fonts_dir(ASS_Library *priv, const char *fonts_dir);
+ASS_EXTERN void ass_set_fonts_dir(ASS_Library *priv, const char *fonts_dir);
 
 /**
  * \brief Whether fonts should be extracted from track data.
  * \param priv library handle
  * \param extract whether to extract fonts
  */
-void ass_set_extract_fonts(ASS_Library *priv, int extract);
+ASS_EXTERN void ass_set_extract_fonts(ASS_Library *priv, int extract);
 
 /**
  * \brief Register style overrides with a library instance.
@@ -236,13 +249,13 @@ void ass_set_extract_fonts(ASS_Library *priv, int extract);
  * \param priv library handle
  * \param list NULL-terminated list of strings
  */
-void ass_set_style_overrides(ASS_Library *priv, char **list);
+ASS_EXTERN void ass_set_style_overrides(ASS_Library *priv, char **list);
 
 /**
  * \brief Explicitly process style overrides for a track.
  * \param track track handle
  */
-void ass_process_force_style(ASS_Track *track);
+ASS_EXTERN void ass_process_force_style(ASS_Track *track);
 
 /**
  * \brief Register a callback for debug/info messages.
@@ -258,7 +271,7 @@ void ass_process_force_style(ASS_Track *track);
  * \param msg_cb pointer to callback function
  * \param data additional data, will be passed to callback
  */
-void ass_set_message_cb(ASS_Library *priv, void (*msg_cb)
+ASS_EXTERN void ass_set_message_cb(ASS_Library *priv, void (*msg_cb)
                         (int level, const char *fmt, va_list args, void *data),
                         void *data);
 
@@ -267,13 +280,13 @@ void ass_set_message_cb(ASS_Library *priv, void (*msg_cb)
  * \param priv library handle
  * \return renderer handle or NULL if failed
  */
-ASS_Renderer *ass_renderer_init(ASS_Library *);
+ASS_EXTERN ASS_Renderer *ass_renderer_init(ASS_Library *);
 
 /**
  * \brief Finalize the renderer.
  * \param priv renderer handle
  */
-void ass_renderer_done(ASS_Renderer *priv);
+ASS_EXTERN void ass_renderer_done(ASS_Renderer *priv);
 
 /**
  * \brief Set the frame size in pixels, including margins.
@@ -287,7 +300,7 @@ void ass_renderer_done(ASS_Renderer *priv);
  * \param w width
  * \param h height
  */
-void ass_set_frame_size(ASS_Renderer *priv, int w, int h);
+ASS_EXTERN void ass_set_frame_size(ASS_Renderer *priv, int w, int h);
 
 /**
  * \brief Set the source image size in pixels.
@@ -300,14 +313,14 @@ void ass_set_frame_size(ASS_Renderer *priv, int w, int h);
  * \param w width
  * \param h height
  */
-void ass_set_storage_size(ASS_Renderer *priv, int w, int h);
+ASS_EXTERN void ass_set_storage_size(ASS_Renderer *priv, int w, int h);
 
 /**
  * \brief Set shaping level. This is merely a hint, the renderer will use
  * whatever is available if the request cannot be fulfilled.
  * \param level shaping level
  */
-void ass_set_shaper(ASS_Renderer *priv, ASS_ShapingLevel level);
+ASS_EXTERN void ass_set_shaper(ASS_Renderer *priv, ASS_ShapingLevel level);
 
 /**
  * \brief Set frame margins.  These values may be negative if pan-and-scan
@@ -337,14 +350,14 @@ void ass_set_shaper(ASS_Renderer *priv, ASS_ShapingLevel level);
  * \param l left margin
  * \param r right margin
  */
-void ass_set_margins(ASS_Renderer *priv, int t, int b, int l, int r);
+ASS_EXTERN void ass_set_margins(ASS_Renderer *priv, int t, int b, int l, int r);
 
 /**
  * \brief Whether margins should be used for placing regular events.
  * \param priv renderer handle
  * \param use whether to use the margins
  */
-void ass_set_use_margins(ASS_Renderer *priv, int use);
+ASS_EXTERN void ass_set_use_margins(ASS_Renderer *priv, int use);
 
 /**
  * \brief Set pixel aspect ratio correction.
@@ -364,7 +377,7 @@ void ass_set_use_margins(ASS_Renderer *priv, int use);
  * \param priv renderer handle
  * \param par pixel aspect ratio (1.0 means square pixels, 0 means default)
  */
-void ass_set_pixel_aspect(ASS_Renderer *priv, double par);
+ASS_EXTERN void ass_set_pixel_aspect(ASS_Renderer *priv, double par);
 
 /**
  * \brief Set aspect ratio parameters.
@@ -374,28 +387,28 @@ void ass_set_pixel_aspect(ASS_Renderer *priv, double par);
  * \param dar display aspect ratio (DAR), prescaled for output PAR
  * \param sar storage aspect ratio (SAR)
  */
-void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar);
+ASS_EXTERN void ass_set_aspect_ratio(ASS_Renderer *priv, double dar, double sar);
 
 /**
  * \brief Set a fixed font scaling factor.
  * \param priv renderer handle
  * \param font_scale scaling factor, default is 1.0
  */
-void ass_set_font_scale(ASS_Renderer *priv, double font_scale);
+ASS_EXTERN void ass_set_font_scale(ASS_Renderer *priv, double font_scale);
 
 /**
  * \brief Set font hinting method.
  * \param priv renderer handle
  * \param ht hinting method
  */
-void ass_set_hinting(ASS_Renderer *priv, ASS_Hinting ht);
+ASS_EXTERN void ass_set_hinting(ASS_Renderer *priv, ASS_Hinting ht);
 
 /**
  * \brief Set line spacing. Will not be scaled with frame size.
  * \param priv renderer handle
  * \param line_spacing line spacing in pixels
  */
-void ass_set_line_spacing(ASS_Renderer *priv, double line_spacing);
+ASS_EXTERN void ass_set_line_spacing(ASS_Renderer *priv, double line_spacing);
 
 /**
  * \brief Set vertical line position.
@@ -403,7 +416,7 @@ void ass_set_line_spacing(ASS_Renderer *priv, double line_spacing);
  * \param line_position vertical line position of subtitles in percent
  * (0-100: 0 = on the bottom (default), 100 = on top)
  */
-void ass_set_line_position(ASS_Renderer *priv, double line_position);
+ASS_EXTERN void ass_set_line_position(ASS_Renderer *priv, double line_position);
 
 /**
  * \brief Get the list of available font providers. The output array
@@ -414,7 +427,7 @@ void ass_set_line_position(ASS_Renderer *priv, double line_position);
  * \param size output, number of providers
  * \return list of available font providers (user owns the returned array)
  */
-void ass_get_available_font_providers(ASS_Library *priv,
+ASS_EXTERN void ass_get_available_font_providers(ASS_Library *priv,
                                       ASS_DefaultFontProvider **providers,
                                       size_t *size);
 
@@ -436,7 +449,7 @@ void ass_get_available_font_providers(ASS_Library *priv,
  *
  * NOTE: font lookup must be configured before an ASS_Renderer can be used.
  */
-void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
+ASS_EXTERN void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
                    const char *default_family, int dfp,
                    const char *config, int update);
 
@@ -455,7 +468,7 @@ void ass_set_fonts(ASS_Renderer *priv, const char *default_font,
  * \param priv renderer handle
  * \param bits bit mask comprised of ASS_OverrideBits values.
  */
-void ass_set_selective_style_override_enabled(ASS_Renderer *priv, int bits);
+ASS_EXTERN void ass_set_selective_style_override_enabled(ASS_Renderer *priv, int bits);
 
 /**
  * \brief Set style for selective style override.
@@ -464,7 +477,7 @@ void ass_set_selective_style_override_enabled(ASS_Renderer *priv, int bits);
  * should initialize it with {0} before setting fields. Strings will be copied
  * by the function.
  */
-void ass_set_selective_style_override(ASS_Renderer *priv, ASS_Style *style);
+ASS_EXTERN void ass_set_selective_style_override(ASS_Renderer *priv, ASS_Style *style);
 
 /**
  * \brief This is a stub and does nothing. Old documentation: Update/build font
@@ -473,7 +486,7 @@ void ass_set_selective_style_override(ASS_Renderer *priv, ASS_Style *style);
  * \param priv renderer handle
  * \return success
  */
-int ass_fonts_update(ASS_Renderer *priv);
+ASS_EXTERN int ass_fonts_update(ASS_Renderer *priv);
 
 /**
  * \brief Set hard cache limits.  Do not set, or set to zero, for reasonable
@@ -483,7 +496,7 @@ int ass_fonts_update(ASS_Renderer *priv);
  * \param glyph_max maximum number of cached glyphs
  * \param bitmap_max_size maximum bitmap cache size (in MB)
  */
-void ass_set_cache_limits(ASS_Renderer *priv, int glyph_max,
+ASS_EXTERN void ass_set_cache_limits(ASS_Renderer *priv, int glyph_max,
                           int bitmap_max_size);
 
 /**
@@ -494,7 +507,7 @@ void ass_set_cache_limits(ASS_Renderer *priv, int glyph_max,
  * \param detect_change compare to the previous call and set to 1
  * if positions changed, or set to 2 if content changed.
  */
-ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
+ASS_EXTERN ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
                             long long now, int *detect_change);
 
 
@@ -508,27 +521,27 @@ ASS_Image *ass_render_frame(ASS_Renderer *priv, ASS_Track *track,
  * \param library handle
  * \return pointer to empty track
  */
-ASS_Track *ass_new_track(ASS_Library *);
+ASS_EXTERN ASS_Track *ass_new_track(ASS_Library *);
 
 /**
  * \brief Deallocate track and all its child objects (styles and events).
  * \param track track to deallocate
  */
-void ass_free_track(ASS_Track *track);
+ASS_EXTERN void ass_free_track(ASS_Track *track);
 
 /**
  * \brief Allocate new style.
  * \param track track
  * \return newly allocated style id
  */
-int ass_alloc_style(ASS_Track *track);
+ASS_EXTERN int ass_alloc_style(ASS_Track *track);
 
 /**
  * \brief Allocate new event.
  * \param track track
  * \return newly allocated event id
  */
-int ass_alloc_event(ASS_Track *track);
+ASS_EXTERN int ass_alloc_event(ASS_Track *track);
 
 /**
  * \brief Delete a style.
@@ -536,7 +549,7 @@ int ass_alloc_event(ASS_Track *track);
  * \param sid style id
  * Deallocates style data. Does not modify track->n_styles.
  */
-void ass_free_style(ASS_Track *track, int sid);
+ASS_EXTERN void ass_free_style(ASS_Track *track, int sid);
 
 /**
  * \brief Delete an event.
@@ -544,7 +557,7 @@ void ass_free_style(ASS_Track *track, int sid);
  * \param eid event id
  * Deallocates event data. Does not modify track->n_events.
  */
-void ass_free_event(ASS_Track *track, int eid);
+ASS_EXTERN void ass_free_event(ASS_Track *track, int eid);
 
 /**
  * \brief Parse a chunk of subtitle stream data.
@@ -552,7 +565,7 @@ void ass_free_event(ASS_Track *track, int eid);
  * \param data string to parse
  * \param size length of data
  */
-void ass_process_data(ASS_Track *track, char *data, int size);
+ASS_EXTERN void ass_process_data(ASS_Track *track, char *data, int size);
 
 /**
  * \brief Parse Codec Private section of the subtitle stream, in Matroska
@@ -561,7 +574,7 @@ void ass_process_data(ASS_Track *track, char *data, int size);
  * \param data string to parse
  * \param size length of data
  */
-void ass_process_codec_private(ASS_Track *track, char *data, int size);
+ASS_EXTERN void ass_process_codec_private(ASS_Track *track, char *data, int size);
 
 /**
  * \brief Parse a chunk of subtitle stream data. A chunk contains exactly one
@@ -577,7 +590,7 @@ void ass_process_codec_private(ASS_Track *track, char *data, int size);
  * \param timecode starting time of the event (milliseconds)
  * \param duration duration of the event (milliseconds)
  */
-void ass_process_chunk(ASS_Track *track, char *data, int size,
+ASS_EXTERN void ass_process_chunk(ASS_Track *track, char *data, int size,
                        long long timecode, long long duration);
 
 /**
@@ -589,13 +602,13 @@ void ass_process_chunk(ASS_Track *track, char *data, int size,
  * Other values are undefined.
  * If this function is not called, the default value is 1.
  */
-void ass_set_check_readorder(ASS_Track *track, int check_readorder);
+ASS_EXTERN void ass_set_check_readorder(ASS_Track *track, int check_readorder);
 
 /**
  * \brief Flush buffered events.
  * \param track track
 */
-void ass_flush_events(ASS_Track *track);
+ASS_EXTERN void ass_flush_events(ASS_Track *track);
 
 /**
  * \brief Read subtitles from file.
@@ -604,7 +617,7 @@ void ass_flush_events(ASS_Track *track);
  * \param codepage encoding (iconv format)
  * \return newly allocated track
 */
-ASS_Track *ass_read_file(ASS_Library *library, char *fname,
+ASS_EXTERN ASS_Track *ass_read_file(ASS_Library *library, char *fname,
                          char *codepage);
 
 /**
@@ -615,7 +628,7 @@ ASS_Track *ass_read_file(ASS_Library *library, char *fname,
  * \param codepage encoding (iconv format)
  * \return newly allocated track
 */
-ASS_Track *ass_read_memory(ASS_Library *library, char *buf,
+ASS_EXTERN ASS_Track *ass_read_memory(ASS_Library *library, char *buf,
                            size_t bufsize, char *codepage);
 /**
  * \brief Read styles from file into already initialized track.
@@ -623,7 +636,7 @@ ASS_Track *ass_read_memory(ASS_Library *library, char *buf,
  * \param codepage encoding (iconv format)
  * \return 0 on success
  */
-int ass_read_styles(ASS_Track *track, char *fname, char *codepage);
+ASS_EXTERN int ass_read_styles(ASS_Track *track, char *fname, char *codepage);
 
 /**
  * \brief Add a memory font.
@@ -632,14 +645,14 @@ int ass_read_styles(ASS_Track *track, char *fname, char *codepage);
  * \param data binary font data
  * \param data_size data size
 */
-void ass_add_font(ASS_Library *library, char *name, char *data,
+ASS_EXTERN void ass_add_font(ASS_Library *library, char *name, char *data,
                   int data_size);
 
 /**
  * \brief Remove all fonts stored in an ass_library object.
  * \param library library handle
  */
-void ass_clear_fonts(ASS_Library *library);
+ASS_EXTERN void ass_clear_fonts(ASS_Library *library);
 
 /**
  * \brief Calculates timeshift from now to the start of some other subtitle
@@ -650,7 +663,7 @@ void ass_clear_fonts(ASS_Library *library);
  * +2 means "the one after the next", -1 means "previous"
  * \return timeshift in milliseconds
  */
-long long ass_step_sub(ASS_Track *track, long long now, int movement);
+ASS_EXTERN long long ass_step_sub(ASS_Track *track, long long now, int movement);
 
 #ifdef __cplusplus
 }
diff --git a/libass/ass_bitmap.c b/libass/ass_bitmap.c
index e46ef0a..6d44c66 100644
--- a/libass/ass_bitmap.c
+++ b/libass/ass_bitmap.c
@@ -18,7 +18,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <stdlib.h>
diff --git a/libass/ass_blur.c b/libass/ass_blur.c
index 109c24d..5996006 100644
--- a/libass/ass_blur.c
+++ b/libass/ass_blur.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <math.h>
diff --git a/libass/ass_cache.c b/libass/ass_cache.c
index 148faa1..48ff701 100644
--- a/libass/ass_cache.c
+++ b/libass/ass_cache.c
@@ -17,7 +17,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <inttypes.h>
diff --git a/libass/ass_coretext.c b/libass/ass_coretext.c
index aed4b02..9e0250f 100644
--- a/libass/ass_coretext.c
+++ b/libass/ass_coretext.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <CoreFoundation/CoreFoundation.h>
diff --git a/libass/ass_directwrite.cpp b/libass/ass_directwrite.cpp
new file mode 100644
index 0000000..f8606db
--- /dev/null
+++ b/libass/ass_directwrite.cpp
@@ -0,0 +1,1000 @@
+/*
+ * Copyright (C) 2015 Stephan Vedder <stephan.vedder@gmail.com>
+ *
+ * This file is part of libass.
+ *
+ * Permission to use, copy, modify, and distribute this software for any
+ * purpose with or without fee is hereby granted, provided that the above
+ * copyright notice and this permission notice appear in all copies.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+ */
+
+#if HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include "ass_compat.h"
+
+#include <initguid.h>
+#include <ole2.h>
+#include <dwrite.h>
+
+#include "ass_directwrite.h"
+#include "ass_utils.h"
+#include "ass_fontselect.h"
+#include "ass_library.h"
+#include <minwinbase.h>
+
+#define NAME_MAX_LENGTH 256
+#define FALLBACK_DEFAULT_FONT L"Arial"
+
+static const ASS_FontMapping font_substitutions[] = {
+    {"sans-serif", "Arial"},
+    {"serif", "Times New Roman"},
+    {"monospace", "Courier New"}
+};
+
+/*
+ * The private data stored for every font, detected by this backend.
+ */
+typedef struct
+{
+    struct IDWriteFont* font;
+    struct IDWriteFontFace* face;
+    struct IDWriteFontFileStream* stream;
+} FontPrivate;
+
+interface LocalFontEnumerator : IDWriteFontFileEnumerator
+{
+    HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObject) override
+    {
+        if (IsEqualGUID(riid, __uuidof(IDWriteFontFileEnumerator))
+            || IsEqualGUID(riid, __uuidof(IUnknown)))
+        {
+            *ppvObject = this;
+        }
+        else
+        {
+            *ppvObject = nullptr;
+            return E_NOINTERFACE;
+        }
+
+        AddRef();
+        return S_OK;
+    }
+
+    ULONG __stdcall AddRef() override
+    {
+        return InterlockedIncrement(&ref_count);
+    }
+
+    ULONG __stdcall Release() override
+    {
+        auto count = InterlockedDecrement(&ref_count);
+        if (count == 0)
+            delete this;
+
+        return count;
+    }
+
+    HRESULT __stdcall MoveNext(BOOL* hasCurrentFile) override
+    {
+        if (hFind == INVALID_HANDLE_VALUE)
+        {
+            hFind = FindFirstFileW(dirPath, &ffd);
+            if (hFind == INVALID_HANDLE_VALUE)
+            {
+                *hasCurrentFile = FALSE;
+                return E_INVALIDARG;
+            }
+
+            while (ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
+            {
+                auto result = FindNextFileW(hFind, &ffd);
+                if (result == 0)
+                {
+                    FindClose(hFind);
+                    hFind = INVALID_HANDLE_VALUE;
+                    *hasCurrentFile = FALSE;
+                    return S_OK;
+                }
+            }
+
+            FileNameToPath(ffd.cFileName);
+            *hasCurrentFile = TRUE;
+            return S_OK;
+        }
+
+        auto result = FindNextFileW(hFind, &ffd);
+        if (result == 0)
+        {
+            FindClose(hFind);
+            hFind = INVALID_HANDLE_VALUE;
+            *hasCurrentFile = FALSE;
+            return S_OK;
+        }
+
+        if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
+            FileNameToPath(ffd.cFileName);
+
+        *hasCurrentFile = TRUE;
+        return S_OK;
+    }
+
+    HRESULT __stdcall GetCurrentFontFile(IDWriteFontFile** fontFile) override
+    {
+        auto hr = factory->CreateFontFileReference(filePath, &ffd.ftLastWriteTime, fontFile);
+        return hr;
+    }
+
+    LocalFontEnumerator(IDWriteFactory* f, char* dir)
+        : ref_count(0)
+        , dirPathLength(0)
+        , dirPath(nullptr)
+        , filePath(nullptr)
+        , hFind(INVALID_HANDLE_VALUE)
+        , factory(f)
+    {
+        LocalFontEnumerator::AddRef();
+        factory->AddRef();
+        int len = strlen(dir);
+        dirPathLength = len + 2; //add an extra for null and another for a * at the end
+        if (len > 32000) //simple sanity checking, around max path length
+            return;
+        //if (!(dir[0] == '\\' && dir[1] == '\\' && dir[2] == '?' && dir[3] == '\\'))
+        //  dirPathLength += 4;
+
+        char* newDir = static_cast<char*>(malloc(dirPathLength));
+        //strcpy_s(newDir, dirPathLength, "\\\\?\\");
+        strcpy_s(newDir, dirPathLength, dir);
+        strcat_s(newDir, dirPathLength, "*");
+
+        dirPath = to_utf16(newDir, dirPathLength);
+        free(newDir);
+        filePath = static_cast<wchar_t*>(malloc(32000 * sizeof(wchar_t)));
+    }
+
+    virtual ~LocalFontEnumerator()
+    {
+        factory->Release();
+        if (dirPath)
+            free(dirPath);
+        if (filePath)
+            free(filePath);
+        if (hFind != INVALID_HANDLE_VALUE)
+            FindClose(hFind);
+    }
+
+private:
+    void FileNameToPath(wchar_t* filename) const
+    {
+        if (dirPath[dirPathLength - 2] == '*')
+            dirPath[dirPathLength - 2] = '\0';
+
+        memset(filePath, 0, 32000 * sizeof(wchar_t));
+        wcscpy_s(filePath, 32000, dirPath);
+        //wcscat_s(filePath, 32000, L"\\");
+        wcscat_s(filePath, 32000, filename);
+    }
+
+    DWORD ref_count;
+    size_t dirPathLength;
+    wchar_t* dirPath;
+    wchar_t* filePath;
+    WIN32_FIND_DATAW ffd;
+    HANDLE hFind;
+    IDWriteFactory* factory;
+};
+
+
+interface LocalFontLoader : IDWriteFontCollectionLoader
+{
+    HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObject) override
+    {
+        if (IsEqualGUID(riid, __uuidof(IDWriteFontCollectionLoader))
+            || IsEqualGUID(riid, __uuidof(IUnknown)))
+        {
+            *ppvObject = this;
+        }
+        else
+        {
+            *ppvObject = nullptr;
+            return E_NOINTERFACE;
+        }
+
+        AddRef();
+        return S_OK;
+    }
+
+    ULONG __stdcall AddRef() override
+    {
+        return InterlockedIncrement(&ref_count);
+    }
+
+    ULONG __stdcall Release() override
+    {
+        auto count = InterlockedDecrement(&ref_count);
+        if (count == 0)
+            delete this;
+
+        return count;
+    }
+
+    LocalFontLoader()
+        : ref_count(0)
+    {
+        LocalFontLoader::AddRef();
+    }
+
+    virtual ~LocalFontLoader() = default;
+
+    HRESULT __stdcall CreateEnumeratorFromKey(IDWriteFactory* factory, void const* collectionKey, UINT32 collectionKeySize, IDWriteFontFileEnumerator** fontFileEnumerator) override;
+private:
+    DWORD ref_count;
+};
+
+/**
+ * Custom text renderer class for logging the fonts used. It does not
+ * actually render anything or do anything apart from that.
+ */
+
+interface FallbackLogTextRenderer : IDWriteTextRenderer
+{
+    HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObject) override;
+    ULONG __stdcall AddRef() override;
+    ULONG __stdcall Release() override;
+    HRESULT __stdcall IsPixelSnappingDisabled(void* clientDrawingContext, BOOL* isDisabled) override;
+    HRESULT __stdcall GetCurrentTransform(void* clientDrawingContext, DWRITE_MATRIX* transform) override;
+    HRESULT __stdcall GetPixelsPerDip(void* clientDrawingContext, FLOAT* pixelsPerDip) override;
+    HRESULT __stdcall DrawGlyphRun(void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuringMode, DWRITE_GLYPH_RUN const* glyphRun, DWRITE_GLYPH_RUN_DESCRIPTION const* glyphRunDescription, IUnknown* clientDrawingEffect) override;
+    HRESULT __stdcall DrawUnderline(void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_UNDERLINE const* underline, IUnknown* clientDrawingEffect) override;
+    HRESULT __stdcall DrawStrikethrough(void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_STRIKETHROUGH const* strikethrough, IUnknown* clientDrawingEffect) override;
+    HRESULT __stdcall DrawInlineObject(void* clientDrawingContext, FLOAT originX, FLOAT originY, IDWriteInlineObject* inlineObject, BOOL isSideways, BOOL isRightToLeft, IUnknown* clientDrawingEffect) override;
+    IDWriteFactory* dw_factory;
+    virtual ~FallbackLogTextRenderer() = default;
+
+private:
+    static DWORD ref_count;
+};
+
+DWORD FallbackLogTextRenderer::ref_count = 0;
+
+typedef struct
+{
+    struct IDWriteFactory* factory;
+    struct LocalFontLoader* loader;
+    struct LocalFontEnumerator* enumerator;
+    char* dirPath;
+} ProviderPrivate;
+
+HRESULT FallbackLogTextRenderer::QueryInterface(const IID& riid, void** ppvObject)
+{
+    if (IsEqualGUID(riid, __uuidof(IDWriteTextRenderer))
+        || IsEqualGUID(riid, __uuidof(IDWritePixelSnapping))
+        || IsEqualGUID(riid, __uuidof(IUnknown)))
+    {
+        *ppvObject = this;
+    }
+    else
+    {
+        *ppvObject = nullptr;
+        return E_NOINTERFACE;
+    }
+
+    AddRef();
+    return S_OK;
+}
+
+ULONG FallbackLogTextRenderer::AddRef()
+{
+    return InterlockedIncrement(&ref_count);
+}
+
+ULONG FallbackLogTextRenderer::Release()
+{
+    auto new_count = InterlockedDecrement(&ref_count);
+    if (new_count == 0)
+    {
+        delete this;
+        return 0;
+    }
+
+    return new_count;
+}
+
+long FallbackLogTextRenderer::IsPixelSnappingDisabled(void* clientDrawingContext, BOOL* isDisabled)
+{
+    *isDisabled = true;
+    return S_OK;
+}
+
+HRESULT FallbackLogTextRenderer::GetCurrentTransform(void* clientDrawingContext, DWRITE_MATRIX* transform)
+{
+    return E_NOTIMPL;
+}
+
+HRESULT FallbackLogTextRenderer::GetPixelsPerDip(void* clientDrawingContext, FLOAT* pixelsPerDip)
+{
+    return E_NOTIMPL;
+}
+
+HRESULT FallbackLogTextRenderer::DrawGlyphRun(void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuringMode, DWRITE_GLYPH_RUN const* glyphRun, DWRITE_GLYPH_RUN_DESCRIPTION const* glyphRunDescription, IUnknown* clientDrawingEffect)
+{
+    HRESULT hr;
+    struct IDWriteFontCollection* font_coll = nullptr;
+    auto font = static_cast<struct IDWriteFont **>(clientDrawingContext);
+
+    hr = dw_factory->GetSystemFontCollection(&font_coll, FALSE);
+    if (FAILED(hr))
+        return E_FAIL;
+
+    hr = font_coll->GetFontFromFontFace(glyphRun->fontFace, font);
+    if (FAILED(hr))
+        return E_FAIL;
+
+    return S_OK;
+}
+
+HRESULT FallbackLogTextRenderer::DrawUnderline(void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_UNDERLINE const* underline, IUnknown* clientDrawingEffect)
+{
+    return S_OK;
+}
+
+HRESULT FallbackLogTextRenderer::DrawStrikethrough(void* clientDrawingContext, FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_STRIKETHROUGH const* strikethrough, IUnknown* clientDrawingEffect)
+{
+    return S_OK;
+}
+
+HRESULT FallbackLogTextRenderer::DrawInlineObject(void* clientDrawingContext, FLOAT originX, FLOAT originY, IDWriteInlineObject* inlineObject, BOOL isSideways, BOOL isRightToLeft, IUnknown* clientDrawingEffect)
+{
+    return S_OK;
+}
+
+static void init_FallbackLogTextRenderer(FallbackLogTextRenderer** r,
+                                         struct IDWriteFactory* factory)
+{
+    *r = new FallbackLogTextRenderer();
+    (*r)->dw_factory = factory;
+    (*r)->AddRef();
+}
+
+HRESULT LocalFontLoader::CreateEnumeratorFromKey(IDWriteFactory* factory, void const* collectionKey, UINT32 collectionKeySize, IDWriteFontFileEnumerator** fontFileEnumerator)
+{
+    auto priv = static_cast<ProviderPrivate*>(const_cast<void*>(collectionKey));
+    priv->enumerator = new LocalFontEnumerator(factory, priv->dirPath);
+    *fontFileEnumerator = priv->enumerator;
+    return S_OK;
+}
+
+/*
+ * This function is called whenever a font is accessed for the
+ * first time. It will create a FontFace for metadata access and
+ * memory reading, which will be stored within the private data.
+ */
+static bool init_font_private_face(FontPrivate* priv)
+{
+    HRESULT hr;
+    struct IDWriteFontFace* face;
+
+    if (priv->face != nullptr)
+        return true;
+
+    hr = priv->font->CreateFontFace(&face);
+    if (FAILED(hr) || !face)
+        return false;
+
+    priv->face = face;
+    return true;
+}
+
+/*
+ * This function is called whenever a font is used for the first
+ * time. It will create a FontStream for memory reading, which
+ * will be stored within the private data.
+ */
+static bool init_font_private_stream(FontPrivate* priv)
+{
+    struct IDWriteFontFile* file = nullptr;
+    struct IDWriteFontFileStream* stream = nullptr;
+    struct IDWriteFontFileLoader* loader = nullptr;
+    UINT32 n_files = 1;
+    const void* refKey = nullptr;
+    UINT32 keySize = 0;
+
+    if (priv->stream != nullptr)
+        return true;
+
+    if (!init_font_private_face(priv))
+        return false;
+
+    /* DirectWrite only supports one file per face */
+    auto hr = priv->face->GetFiles(&n_files, &file);
+    if (FAILED(hr) || !file)
+        return false;
+
+    hr = file->GetReferenceKey(&refKey, &keySize);
+    if (FAILED(hr))
+    {
+        file->Release();
+        return false;
+    }
+
+    hr = file->GetLoader(&loader);
+    if (FAILED(hr) || !loader)
+    {
+        file->Release();
+        return false;
+    }
+
+    hr = loader->CreateStreamFromKey(refKey, keySize, &stream);
+    if (FAILED(hr) || !stream)
+    {
+        file->Release();
+        return false;
+    }
+
+    priv->stream = stream;
+    file->Release();
+
+    return true;
+}
+
+/*
+ * Read a specified part of a fontfile into memory.
+ * If the font wasn't used before first creates a
+ * FontStream and save it into the private data for later usage.
+ * If the parameter "buf" is NULL libass wants to know the
+ * size of the Fontfile
+ */
+static size_t get_data(void* data, unsigned char* buf, size_t offset,
+                       size_t length)
+{
+    HRESULT hr;
+    auto priv = static_cast<FontPrivate *>(data);
+    const void* fileBuf = nullptr;
+    void* fragContext = nullptr;
+
+    if (!init_font_private_stream(priv))
+        return 0;
+
+    if (buf == nullptr)
+    {
+        UINT64 fileSize;
+        hr = priv->stream->GetFileSize(&fileSize);
+        if (FAILED(hr))
+            return 0;
+
+        return fileSize;
+    }
+
+    hr = priv->stream->ReadFileFragment(&fileBuf, offset,
+                                        length, &fragContext);
+
+    if (FAILED(hr) || !fileBuf)
+        return 0;
+
+    memcpy(buf, fileBuf, length);
+
+    priv->stream->ReleaseFileFragment(fragContext);
+
+    return length;
+}
+
+/*
+ * Check whether the font contains PostScript outlines.
+ */
+static bool check_postscript(void* data)
+{
+    auto priv = static_cast<FontPrivate *>(data);
+
+    if (!init_font_private_face(priv))
+        return false;
+
+    auto type = priv->face->GetType();
+    return type == DWRITE_FONT_FACE_TYPE_CFF ||
+        type == DWRITE_FONT_FACE_TYPE_RAW_CFF ||
+        type == DWRITE_FONT_FACE_TYPE_TYPE1;
+}
+
+/*
+ * Check if the passed font has a specific unicode character.
+ */
+static bool check_glyph(void* data, uint32_t code)
+{
+    auto priv = static_cast<FontPrivate *>(data);
+    auto exists = FALSE;
+
+    if (code == 0)
+        return true;
+
+    auto hr = priv->font->HasCharacter(code, &exists);
+    if (FAILED(hr))
+        return false;
+
+    return exists;
+}
+
+/*
+ * This will release the directwrite backend
+ */
+static void destroy_provider(void* priv)
+{
+    auto provider_priv = static_cast<ProviderPrivate *>(priv);
+    provider_priv->factory->Release();
+    free(provider_priv);
+}
+
+/*
+ * This will destroy a specific font and it's
+ * Fontstream (in case it does exist)
+ */
+
+static void destroy_font(void* data)
+{
+    auto priv = static_cast<FontPrivate *>(data);
+
+    priv->font->Release();
+    if (priv->face != nullptr)
+        priv->face->Release();
+    if (priv->stream != nullptr)
+        priv->stream->Release();
+
+    free(priv);
+}
+
+static int encode_utf16(wchar_t* chars, uint32_t codepoint)
+{
+    if (codepoint < 0x10000)
+    {
+        chars[0] = codepoint;
+        return 1;
+    }
+    else
+    {
+        chars[0] = (codepoint >> 10) + 0xD7C0;
+        chars[1] = (codepoint & 0x3FF) + 0xDC00;
+        return 2;
+    }
+}
+
+static char* get_fallback(void* priv, const char* base, uint32_t codepoint)
+{
+    HRESULT hr;
+    auto provider_priv = static_cast<ProviderPrivate *>(priv);
+    auto dw_factory = provider_priv->factory;
+    struct IDWriteTextFormat* text_format = nullptr;
+    struct IDWriteTextLayout* text_layout = nullptr;
+    FallbackLogTextRenderer* renderer;
+
+    init_FallbackLogTextRenderer(&renderer, dw_factory);
+
+    auto requested_font = to_utf16(base, 0);
+
+    hr = dw_factory->CreateTextFormat(requested_font ? requested_font : FALLBACK_DEFAULT_FONT,
+                                   nullptr,
+                                   DWRITE_FONT_WEIGHT_MEDIUM, DWRITE_FONT_STYLE_NORMAL,
+                                   DWRITE_FONT_STRETCH_NORMAL, 1.0f, L"", &text_format);
+    free(requested_font);
+    if (FAILED(hr))
+        return nullptr;
+
+    // Encode codepoint as UTF-16
+    wchar_t char_string[2];
+    auto char_len = encode_utf16(char_string, codepoint);
+
+    // Create a text_layout, a high-level text rendering facility, using
+    // the given codepoint and dummy format.
+    hr = dw_factory->CreateTextLayout(char_string, char_len, text_format,
+                                      0.0f, 0.0f, &text_layout);
+    if (FAILED(hr))
+    {
+        text_format->Release();
+        return nullptr;
+    }
+
+    // Draw the layout with a dummy renderer, which logs the
+    // font used and stores it.
+    struct IDWriteFont* font = nullptr;
+    hr = text_layout->Draw(&font, renderer, 0.0f, 0.0f);
+    // We're done with these now
+    text_layout->Release();
+    text_format->Release();
+    renderer->Release();
+    if (FAILED(hr) || font == nullptr)
+    {
+        return nullptr;
+    }
+
+
+    // Now, just extract the first family name
+    auto exists = FALSE;
+    struct IDWriteLocalizedStrings* familyNames = nullptr;
+    hr = font->GetInformationalStrings(
+        DWRITE_INFORMATIONAL_STRING_WIN32_FAMILY_NAMES,
+        &familyNames, &exists);
+    if (FAILED(hr) || !exists)
+    {
+        font->Release();
+        return nullptr;
+    }
+
+    wchar_t temp_name[NAME_MAX_LENGTH];
+    hr = familyNames->GetString(0, temp_name, NAME_MAX_LENGTH);
+    if (FAILED(hr))
+    {
+        familyNames->Release();
+        font->Release();
+        return nullptr;
+    }
+    temp_name[NAME_MAX_LENGTH - 1] = 0;
+
+    // DirectWrite may not have found a valid fallback, so check that
+    // the selected font actually has the requested glyph.
+    if (codepoint > 0)
+    {
+        hr = font->HasCharacter(codepoint, &exists);
+        if (FAILED(hr) || !exists)
+        {
+            familyNames->Release();
+            font->Release();
+            return nullptr;
+        }
+    }
+
+    auto family = to_utf8(temp_name, 0);
+
+    familyNames->Release();
+    font->Release();
+    return family;
+}
+
+static int map_width(enum DWRITE_FONT_STRETCH stretch)
+{
+    switch (stretch)
+    {
+    case DWRITE_FONT_STRETCH_ULTRA_CONDENSED: return 50;
+    case DWRITE_FONT_STRETCH_EXTRA_CONDENSED: return 63;
+    case DWRITE_FONT_STRETCH_CONDENSED: return FONT_WIDTH_CONDENSED;
+    case DWRITE_FONT_STRETCH_SEMI_CONDENSED: return 88;
+    case DWRITE_FONT_STRETCH_MEDIUM: return FONT_WIDTH_NORMAL;
+    case DWRITE_FONT_STRETCH_SEMI_EXPANDED: return 113;
+    case DWRITE_FONT_STRETCH_EXPANDED: return FONT_WIDTH_EXPANDED;
+    case DWRITE_FONT_STRETCH_EXTRA_EXPANDED: return 150;
+    case DWRITE_FONT_STRETCH_ULTRA_EXPANDED: return 200;
+    default:
+        return FONT_WIDTH_NORMAL;
+    }
+}
+
+static char* get_font_path(IDWriteFont* font)
+{
+    IDWriteFontFace* fontFace;
+    auto hr = font->CreateFontFace(&fontFace);
+    if (FAILED(hr))
+        return nullptr;
+
+    IDWriteFontFile* fontFiles[1];
+    UINT32 files = 1;
+    hr = fontFace->GetFiles(&files, fontFiles);
+    if (FAILED(hr))
+    {
+        fontFace->Release();
+        return nullptr;
+    }
+
+    const wchar_t* refKey = nullptr;
+    hr = fontFiles[0]->GetReferenceKey(reinterpret_cast<void const **>(&refKey), &files);
+    if (FAILED(hr))
+    {
+        fontFace->Release();
+        for (auto f : fontFiles)
+            f->Release();
+        return nullptr;
+    }
+
+    // This must be before we release the reference because the key is
+    // only guaranteed to be valid until release
+    char* path = nullptr;
+    auto start = wcschr(refKey, L':');
+    if (start)
+    {
+        auto diff = start - refKey - 1;
+        auto length = files / 2 - diff;
+        path = to_utf8(start - 1, length);
+    }
+
+    fontFace->Release();
+    for (auto f : fontFiles)
+        f->Release();
+
+    return path;
+}
+
+static void add_font(struct IDWriteFont* font, struct IDWriteFontFamily* fontFamily,
+                     ASS_FontProvider* provider)
+{
+    HRESULT hr;
+    BOOL exists;
+    wchar_t temp_name[NAME_MAX_LENGTH];
+    ASS_FontProviderMetaData meta = {nullptr};
+
+    meta.weight = font->GetWeight();
+    meta.width = map_width(font->GetStretch());
+
+    auto style = font->GetStyle();
+    meta.slant = (style == DWRITE_FONT_STYLE_NORMAL) ? FONT_SLANT_NONE :
+                     (style == DWRITE_FONT_STYLE_OBLIQUE) ? FONT_SLANT_OBLIQUE :
+                     (style == DWRITE_FONT_STYLE_ITALIC) ? FONT_SLANT_ITALIC : FONT_SLANT_NONE;
+
+    struct IDWriteLocalizedStrings* psNames;
+    hr = font->GetInformationalStrings(
+        DWRITE_INFORMATIONAL_STRING_POSTSCRIPT_NAME, &psNames, &exists);
+    if (FAILED(hr))
+        goto cleanup;
+
+    if (exists)
+    {
+        hr = psNames->GetString(0, temp_name, NAME_MAX_LENGTH);
+        if (FAILED(hr))
+        {
+            psNames->Release();
+            goto cleanup;
+        }
+
+        temp_name[NAME_MAX_LENGTH - 1] = 0;
+        auto mbName = to_utf8(temp_name, 0);
+        if (!mbName)
+        {
+            psNames->Release();
+            goto cleanup;
+        }
+        meta.postscript_name = mbName;
+
+        psNames->Release();
+    }
+
+    struct IDWriteLocalizedStrings* fontNames;
+    hr = font->GetInformationalStrings(
+        DWRITE_INFORMATIONAL_STRING_FULL_NAME, &fontNames, &exists);
+    if (FAILED(hr))
+        goto cleanup;
+
+    if (exists)
+    {
+        meta.n_fullname = fontNames->GetCount();
+        meta.fullnames = static_cast<char **>(calloc(meta.n_fullname, sizeof(char *)));
+        if (!meta.fullnames)
+        {
+            fontNames->Release();
+            goto cleanup;
+        }
+        for (int k = 0; k < meta.n_fullname; k++)
+        {
+            hr = fontNames->GetString(k, temp_name, NAME_MAX_LENGTH);
+            if (FAILED(hr))
+            {
+                fontNames->Release();
+                goto cleanup;
+            }
+
+            temp_name[NAME_MAX_LENGTH - 1] = 0;
+            char* mbName = to_utf8(temp_name, 0);
+            if (!mbName)
+            {
+                fontNames->Release();
+                goto cleanup;
+            }
+            meta.fullnames[k] = mbName;
+        }
+        fontNames->Release();
+    }
+
+    struct IDWriteLocalizedStrings* familyNames;
+    hr = font->GetInformationalStrings(
+        DWRITE_INFORMATIONAL_STRING_WIN32_FAMILY_NAMES, &familyNames, &exists);
+    if (FAILED(hr) || !exists)
+        hr = fontFamily->GetFamilyNames(&familyNames);
+    if (FAILED(hr))
+        goto cleanup;
+
+    meta.n_family = familyNames->GetCount();
+    meta.families = static_cast<char **>(calloc(meta.n_family, sizeof(char *)));
+    if (!meta.families)
+    {
+        familyNames->Release();
+        goto cleanup;
+    }
+    for (auto k = 0; k < meta.n_family; k++)
+    {
+        hr = familyNames->GetString(k, temp_name, NAME_MAX_LENGTH);
+        if (FAILED(hr))
+        {
+            familyNames->Release();
+            goto cleanup;
+        }
+
+        temp_name[NAME_MAX_LENGTH - 1] = 0;
+        auto mbName = to_utf8(temp_name, 0);
+        if (!mbName)
+        {
+            familyNames->Release();
+            goto cleanup;
+        }
+        meta.families[k] = mbName;
+    }
+    familyNames->Release();
+
+    auto path = get_font_path(font);
+
+    FontPrivate* font_priv = static_cast<FontPrivate *>(calloc(1, sizeof(*font_priv)));
+    if (!font_priv)
+        goto cleanup;
+    font_priv->font = font;
+    font = nullptr;
+
+    ass_font_provider_add_font(provider, &meta, path, 0, font_priv);
+
+cleanup:
+    if (meta.families)
+    {
+        for (int k = 0; k < meta.n_family; k++)
+            free(meta.families[k]);
+        free(meta.families);
+    }
+
+    if (meta.fullnames)
+    {
+        for (int k = 0; k < meta.n_fullname; k++)
+            free(meta.fullnames[k]);
+        free(meta.fullnames);
+    }
+
+    free(meta.postscript_name);
+
+    if (font)
+        font->Release();
+}
+
+/*
+ * Scan every system font on the current machine and add it
+ * to the libass lookup. Stores the FontPrivate as private data
+ * for later memory reading
+ */
+static void scan_fonts(struct IDWriteFactory* factory,
+                       struct IDWriteFontCollection* fontCollection,
+                       ASS_FontProvider* provider)
+{
+    struct IDWriteFont* font = nullptr;
+    HRESULT hr;
+
+    UINT32 familyCount = fontCollection->GetFontFamilyCount();
+
+    for (UINT32 i = 0; i < familyCount; ++i)
+    {
+        struct IDWriteFontFamily* fontFamily = nullptr;
+
+        hr = fontCollection->GetFontFamily(i, &fontFamily);
+        if (FAILED(hr))
+            continue;
+
+        UINT32 fontCount = fontFamily->GetFontCount();
+        for (UINT32 j = 0; j < fontCount; ++j)
+        {
+            hr = fontFamily->GetFont(j, &font);
+            if (FAILED(hr))
+                continue;
+
+            // Simulations for bold or oblique are sometimes synthesized by
+            // DirectWrite. We are only interested in physical fonts.
+            if (font->GetSimulations() != 0)
+            {
+                font->Release();
+                continue;
+            }
+
+            add_font(font, fontFamily, provider);
+        }
+
+        fontFamily->Release();
+    }
+
+    fontCollection->Release();
+}
+
+static void get_substitutions(void* priv, const char* name,
+                              ASS_FontProviderMetaData* meta)
+{
+    const int n = sizeof(font_substitutions) / sizeof(font_substitutions[0]);
+    ass_map_font(font_substitutions, n, name, meta);
+}
+
+/*
+ * Called by libass when the provider should perform the
+ * specified task
+ */
+static ASS_FontProviderFuncs directwrite_callbacks = {
+    get_data,
+    check_postscript,
+    check_glyph,
+    destroy_font,
+    destroy_provider,
+    nullptr,
+    get_substitutions,
+    get_fallback,
+};
+
+/*
+ * Register the directwrite provider. Upon registering
+ * scans all system fonts. The private data for this
+ * provider is IDWriteFactory
+ * On failure returns NULL
+ */
+extern "C"
+{
+    ASS_FontProvider* ass_directwrite_add_provider(ASS_Library* lib,
+                                                   ASS_FontSelector* selector,
+                                                   const char* config)
+    {
+        struct IDWriteFactory* dwFactory = nullptr;
+        ASS_FontProvider* provider;
+        ProviderPrivate* priv = nullptr;
+
+        auto hr = DWriteCreateFactory(DWRITE_FACTORY_TYPE_SHARED,
+                                      __uuidof(IDWriteFactory),
+                                      reinterpret_cast<IUnknown **>(&dwFactory));
+        if (FAILED(hr) || !dwFactory)
+        {
+            ass_msg(lib, MSGL_WARN, "Failed to initialize directwrite.");
+            dwFactory = nullptr;
+            goto cleanup;
+        }
+
+        priv = static_cast<ProviderPrivate *>(calloc(sizeof(*priv), 1));
+        if (!priv)
+            goto cleanup;
+
+        priv->dirPath = lib->fonts_dir;
+        priv->factory = dwFactory;
+        priv->loader = new LocalFontLoader();
+        hr = dwFactory->RegisterFontCollectionLoader(priv->loader);
+        if (FAILED(hr))
+            goto cleanup;
+
+        IDWriteFontCollection* collection;
+        hr = dwFactory->CreateCustomFontCollection(priv->loader, static_cast<void*>(priv), sizeof(ProviderPrivate), &collection);
+        if (FAILED(hr))
+            goto cleanup;
+
+        provider = ass_font_provider_new(selector, &directwrite_callbacks, priv);
+        if (!provider)
+            goto cleanup;
+
+        IDWriteFontCollection* systemCollection;
+        hr = dwFactory->GetSystemFontCollection(&systemCollection, FALSE);
+        if (FAILED(hr))
+            goto cleanup;
+
+        scan_fonts(dwFactory, systemCollection, provider);
+        scan_fonts(dwFactory, collection, provider);
+
+        return provider;
+
+    cleanup:
+        if (priv->enumerator)
+            priv->enumerator->Release();
+        if (priv->loader)
+            priv->loader->Release();
+
+        free(priv);
+        if (dwFactory)
+            dwFactory->Release();
+
+        return nullptr;
+    }
+}
diff --git a/libass/ass_directwrite.h b/libass/ass_directwrite.h
index acb2e19..44f9cc1 100644
--- a/libass/ass_directwrite.h
+++ b/libass/ass_directwrite.h
@@ -16,14 +16,20 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
-#include "ass_types.h"
-#include "ass_fontselect.h"
-
 #ifndef ASS_DIRECTWRITE_H
 #define ASS_DIRECTWRITE_H
 
+#include "ass_types.h"
+#include "ass_fontselect.h"
+
+#if __cplusplus
+extern "C" {
+#endif
 ASS_FontProvider *
 ass_directwrite_add_provider(ASS_Library *lib, ASS_FontSelector *selector,
                           const char *config);
+#if __cplusplus
+}
+#endif
 
 #endif
diff --git a/libass/ass_drawing.c b/libass/ass_drawing.c
index 3428d21..f0bff60 100644
--- a/libass/ass_drawing.c
+++ b/libass/ass_drawing.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <ft2build.h>
diff --git a/libass/ass_font.c b/libass/ass_font.c
index 5889b49..fef5486 100644
--- a/libass/ass_font.c
+++ b/libass/ass_font.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <inttypes.h>
diff --git a/libass/ass_fontconfig.c b/libass/ass_fontconfig.c
index 304598e..dbdb68d 100644
--- a/libass/ass_fontconfig.c
+++ b/libass/ass_fontconfig.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #ifdef CONFIG_FONTCONFIG
diff --git a/libass/ass_fontselect.c b/libass/ass_fontselect.c
index 5426b15..b961eab 100644
--- a/libass/ass_fontselect.c
+++ b/libass/ass_fontselect.c
@@ -17,7 +17,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <stdlib.h>
@@ -31,7 +33,12 @@
 #include <limits.h>
 #include <ft2build.h>
 #include <sys/types.h>
+#if HAVE_DIRENT_H
 #include <dirent.h>
+#else
+#define WIN32_LEAN_AND_MEAN 1
+#include <windows.h>
+#endif
 #include FT_FREETYPE_H
 #include FT_SFNT_NAMES_H
 #include FT_TRUETYPE_IDS_H
@@ -161,6 +168,7 @@ static ASS_FontProviderFuncs ft_funcs = {
     .destroy_font      = destroy_font_ft,
 };
 
+#if HAVE_DIRENT_H
 static void load_fonts_from_dir(ASS_Library *library, const char *dir)
 {
     DIR *d = opendir(dir);
@@ -184,6 +192,65 @@ static void load_fonts_from_dir(ASS_Library *library, const char *dir)
     }
     closedir(d);
 }
+#else
+
+static void load_fonts_from_dir(ASS_Library *library, const char *dir)
+{
+  int len = strlen(dir);
+  int newLen = len + 1; //add an extra for null
+  if (len > 32000) //simple sanity checking, around max path length
+    return;
+  if (!(dir[0] == '\\' && dir[1] == '\\' && dir[2] == '?' && dir[3] == '\\'))
+    newLen += 4;
+
+  char * newDir = malloc(newLen);
+  strcpy_s(newDir, newLen, "\\\\?\\");
+  strcat_s(newDir, newLen, dir);
+
+  wchar_t *dirPath = to_utf16(newDir, newLen);
+  free(newDir);
+
+  if (!dirPath)
+    return;
+
+  WIN32_FIND_DATAW ffd;
+  HANDLE hFind;
+
+  hFind = FindFirstFileW(dirPath, &ffd);
+  if (hFind == INVALID_HANDLE_VALUE)
+  {
+    free(dirPath);
+    return;
+  }
+
+  do
+  {
+    if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
+    {
+      wchar_t buf[4000];
+      wcscpy_s(buf, 4000, dirPath);
+      wcscat_s(buf, 4000, L"\\");
+      wcscat_s(buf, 4000, ffd.cFileName);
+      size_t bufSize;
+      //we assume file size is less than 4GB, otherwise we're in trouble
+      //anyway
+      void *data = read_fileW(library, buf, ffd.nFileSizeLow, &bufSize);
+        if (data) {
+          char *name = to_utf8(ffd.cFileName, 0);
+          if (name)
+          {
+            ass_add_font(library, name, data, bufSize);
+            free(name);
+          }
+          free(data);
+        }
+    }
+  } while (FindNextFileW(hFind, &ffd) != 0);
+  FindClose(hFind);
+
+  free(dirPath);
+}
+#endif
 
 /**
  * \brief Create a bare font provider.
diff --git a/libass/ass_fontselect.h b/libass/ass_fontselect.h
index 73d5265..cb236df 100644
--- a/libass/ass_fontselect.h
+++ b/libass/ass_fontselect.h
@@ -32,6 +32,9 @@ typedef struct font_info ASS_FontInfo;
 #include "ass.h"
 #include "ass_font.h"
 
+#if __cplusplus
+extern "C" {
+#endif
 typedef struct font_provider ASS_FontProvider;
 
 /* Font Provider */
@@ -262,4 +265,7 @@ ass_font_provider_add_font(ASS_FontProvider *provider,
  */
 void ass_font_provider_free(ASS_FontProvider *provider);
 
+#if __cplusplus
+}
+#endif
 #endif                          /* LIBASS_FONTCONFIG_H */
diff --git a/libass/ass_library.c b/libass/ass_library.c
index 6ee5f81..c3b6b9a 100644
--- a/libass/ass_library.c
+++ b/libass/ass_library.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <inttypes.h>
diff --git a/libass/ass_library.h b/libass/ass_library.h
index 8144f8e..70775de 100644
--- a/libass/ass_library.h
+++ b/libass/ass_library.h
@@ -39,5 +39,8 @@ struct ass_library {
 };
 
 char *read_file(struct ass_library *library, char *fname, size_t *bufsize);
+#ifndef HAVE_DIRENT_H
+char *read_fileW(struct ass_library *library, wchar_t *fname, unsigned long fileSize, size_t *bufSize);
+#endif
 
 #endif                          /* LIBASS_LIBRARY_H */
diff --git a/libass/ass_parse.c b/libass/ass_parse.c
index 5cd232f..3b0e225 100644
--- a/libass/ass_parse.c
+++ b/libass/ass_parse.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <stdio.h>
diff --git a/libass/ass_rasterizer.c b/libass/ass_rasterizer.c
index dbad5a1..bd516c0 100644
--- a/libass/ass_rasterizer.c
+++ b/libass/ass_rasterizer.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include "ass_utils.h"
diff --git a/libass/ass_rasterizer_c.c b/libass/ass_rasterizer_c.c
index 324cdca..75619af 100644
--- a/libass/ass_rasterizer_c.c
+++ b/libass/ass_rasterizer_c.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include "ass_utils.h"
diff --git a/libass/ass_render.c b/libass/ass_render.c
index d0f827d..f6ae938 100644
--- a/libass/ass_render.c
+++ b/libass/ass_render.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <assert.h>
diff --git a/libass/ass_render_api.c b/libass/ass_render_api.c
index d4b55de..0186a72 100644
--- a/libass/ass_render_api.c
+++ b/libass/ass_render_api.c
@@ -17,7 +17,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include "ass_render.h"
diff --git a/libass/ass_shaper.c b/libass/ass_shaper.c
index 5f24c5a..a52d69c 100644
--- a/libass/ass_shaper.c
+++ b/libass/ass_shaper.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include "ass_shaper.h"
diff --git a/libass/ass_string.c b/libass/ass_string.c
index c19efad..224b4b9 100644
--- a/libass/ass_string.c
+++ b/libass/ass_string.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include "ass_string.h"
diff --git a/libass/ass_strtod.c b/libass/ass_strtod.c
index 3b9ec3f..29d0d48 100644
--- a/libass/ass_strtod.c
+++ b/libass/ass_strtod.c
@@ -13,7 +13,9 @@
  *
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <stdlib.h>
diff --git a/libass/ass_utils.c b/libass/ass_utils.c
index 9dc2358..881d026 100644
--- a/libass/ass_utils.c
+++ b/libass/ass_utils.c
@@ -16,7 +16,9 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */
 
+#if HAVE_CONFIG_H
 #include "config.h"
+#endif
 #include "ass_compat.h"
 
 #include <stddef.h>
@@ -29,6 +31,9 @@
 #include "ass.h"
 #include "ass_utils.h"
 #include "ass_string.h"
+#if defined(WIN32) || defined(_MSC_VER)
+#include <windows.h>
+#endif
 
 #if (defined(__i386__) || defined(__x86_64__)) && CONFIG_ASM
 
@@ -507,3 +512,53 @@ ASS_Style *lookup_style_strict(ASS_Track *track, char *name, size_t len)
     return NULL;
 }
 
+#if defined(WIN32) || defined(_MSC_VER)
+wchar_t* to_utf16(const char* str, size_t length)
+{
+  if (length == 0)
+    length = strlen(str);
+
+  int result = MultiByteToWideChar(CP_UTF8, 0, str, length, NULL, 0);
+  if (result == 0)
+    return NULL;
+
+  length = result + 1;
+  wchar_t* dirPath = malloc(length * 2);
+  result = MultiByteToWideChar(CP_UTF8, 0, str, result, dirPath, length);
+
+  if (result == 0)
+  {
+    free(dirPath);
+    return NULL;
+  }
+
+  if (dirPath[length - 1] != '\0')
+    dirPath[length - 1] = '\0';
+
+  return dirPath;
+}
+
+char* to_utf8(const wchar_t* str, size_t length)
+{
+  if (length == 0)
+    length = wcslen(str);
+
+  int result = WideCharToMultiByte(CP_UTF8, 0, str, length, NULL, 0, NULL, NULL);
+  if (result == 0)
+    return NULL;
+
+  int required = result + 1;
+  char *newStr = malloc(required);
+  result = WideCharToMultiByte(CP_UTF8, 0, str, length, newStr, required, NULL, NULL);
+  if (result == 0)
+  {
+    free(newStr);
+    return NULL;
+  }
+
+  if (newStr[required - 1] != '\0')
+    newStr[required - 1] = '\0';
+  
+  return newStr;
+}
+#endif
\ No newline at end of file
diff --git a/libass/ass_utils.h b/libass/ass_utils.h
index 6c9f385..eec43aa 100644
--- a/libass/ass_utils.h
+++ b/libass/ass_utils.h
@@ -46,6 +46,10 @@
 #define FFMIN(a,b) ((a) > (b) ? (b) : (a))
 #define FFMINMAX(c,a,b) FFMIN(FFMAX(c, a), b)
 
+#if __cplusplus
+extern "C" {
+#endif
+
 #if (defined(__i386__) || defined(__x86_64__)) && CONFIG_ASM
 int has_sse2(void);
 int has_avx(void);
@@ -201,4 +201,11 @@ static inline unsigned fnv_32a_str(char *str, unsigned hval)
     return hval;
 }
 
+#if defined(WIN32) || defined(_MSC_VER)
+wchar_t* to_utf16(const char* str, size_t length);
+char* to_utf8(const wchar_t* str, size_t length);
+#endif
+#if __cplusplus
+}
+#endif
 #endif                          /* LIBASS_UTILS_H */
